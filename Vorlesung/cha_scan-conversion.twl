\chapter{Scan Conversion}

\begin{description}
\item[Problem:]
  Gegeben ist eine Menge von â€Objektenâ€œ.
  \begin{itemize}
  \item \xfigGreenIII{Linie} von $(7, 3)$ nach $(16, 5)$
  \item \xfigBlue{Linie} von $(9, 8)$ nach $(12, 2)$
  \item \xfigRed{ausgefÃ¼lltes Polygon} mit den Eckpunkten
    $(5, 1)$, $(4, 6)$, $(1, 8)$, $(-2, 3)$
  \item â€¦
  \end{itemize}

  Gesucht sind die zu jedem Objekt gehÃ¶renden Rasterpunkte
  (picture elements, \emph{â€Pixelsâ€œ}\index{Pixel}).

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_scanconversion}}%
    \index{logischer Bildwiederholspeicher}\index{Bildwiederholspeicher!logischer}%
    \index{Pixel Map}\index{Pixmap}
  \end{center}
\end{description}
\Reached{WS19/20}{01}{2019/10/10}
\ReachedZoom{WS20/21}{01}{2020/10/29}

\pagebreak

\begin{bemerkung}
  Die Pixmap muss nicht mit dem aktuellen (dem Video Controller
  zugÃ¤nglichen) Bildwiederholspeicher Ã¼bereinstimmen!

  \textbf{Anwendung 1:} \emph{â€Doppelpufferungâ€œ}\index{Doppelpufferung}

  \begin{description}
  \item[Problem:]
    Gleichzeitiges VerÃ¤ndern und Auslesen des
    Bildwiederholspeichers fÃ¼hrt zu unerwÃ¼nschten Effekten.

    (meist: Verzerrungen, Flackern)

  \item[Beispiel:]
    Aus einem (relativ komplexen) Bild soll ein Objekt gelÃ¶scht
    werden.

    mÃ¶glicher Ablauf ohne Doppelpufferung:

    (Painter's Algorithm
    â‡ Abschnitt~\ref{subsec:paintersAlgorithm})

    \begin{center}
      \scalebox{0.7}{\large\input{fig_scanPaintersOhneDoppelpufferung}}
    \end{center}

    \pagebreak

  \item[Abhilfe:] Verwende zwei Pixmaps.
    
    Es wird immer nur die Pixmap modifiziert, die gerade nicht
    vom Video Controller ausgelesen wird.
    
    \begin{center}
      \scalebox{0.6}{\LARGE\input{fig_scanDoppelpufferung}}%â‚â‚‚
    \end{center}
  \end{description}

  \textbf{Anwendung 2:} Verwaltung einer FensteroberflÃ¤che

  \begin{center}
    \scalebox{0.5}{\huge\input{fig_scanFensteroberflaeche}}
  \end{center}
  \Reached{WS15/16}{01}{2015/10/22}

  \pagebreak

  \textbf{Anwendung 3:} Rasterung fÃ¼r ein anderes GerÃ¤t
  
  (\zB Drucker)
\end{bemerkung}

\begin{bemerkung}
  FÃ¼r eine Pixmap der GrÃ¶ÃŸe $nâ‚“ Ã— n_y$ wird ein
  Speicherbereich passender GrÃ¶ÃŸe reserviert.

  \begin{itemize}
  \item[â‡’] Pixel auÃŸerhalb der Pixmap dÃ¼rfen nicht
    modifiziert werden.

  \item[â‡’] Die Objekte werden an den Grenzen der Pixmap
    â€abgeschnittenâ€œ.

    â‡ â€Clippingâ€œ (Kapitel~\ref{cha:clipping})
  \end{itemize}
\end{bemerkung}
\Reached{WS16/17}{01}{2016/10/20}

\pagebreak


\section{Scan Conversion fÃ¼r Strecken}

\begin{description}
\item[Annahmen:] \mbox{}

  \begin{itemize}
  \item Die Endpunkte der Strecken haben ganzzahlige Koordinaten:
    \[ \rk{xâ‚, yâ‚} âˆˆ â„¤Â² \,\text, \quad \rk{xâ‚‚, yâ‚‚} âˆˆ â„¤Â² \]
  \item $xâ‚ < xâ‚‚$
  \item FÃ¼r die Steigung $m$ der Strecke gilt:
    \[ \abs{m} â‰¤ 1 \]
    (Sonst vertauscht man die Rollen von $x$ und $y$.)
  \end{itemize}
  
\item[Ziel:] FÃ¼r jeden $x$-Wert soll genau ein Pixel gesetzt
  werden, das mÃ¶glichst nahe an der Strecke liegt.
\end{description}

\pagebreak

\begin{beispiel} \mbox{}
  \begin{center}
    \scalebox{0.7}{\large\input{fig_scanStreckePrinzip}}
  \end{center}
\end{beispiel}
\Reached{WS21/22}{01}{2021/10/14}

\pagebreak


\subsection{Das naive Verfahren}

\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus Scan Conversion ÂºfÃ¼rÂº Strecke, naiv

    $m$ := $\frac{yâ‚‚ - yâ‚}{xâ‚‚ - xâ‚}$
    $b$ := $yâ‚ - m Â· xâ‚$
    // $y = m x + b$ ist die Steigungsform der Geraden durch $\rk{xâ‚, yâ‚}$ und $\rk{xâ‚‚, yâ‚‚}$
    fÃ¼r $x = xâ‚, xâ‚ + 1, â€¦, xâ‚‚$
    Â°Â°Â°$y$ := $m x + b$
    Â°Â°Â°modifiziere Pixel $(x, \round(y))$
  \end{AlgListInline}
\end{algorithmus}

\begin{description}
\item[Problem:]
  viele Operationen mit reellen Zahlen sowie
  \begin{center}
    \emph{Rundung} reell â‡ ganzzahlig
  \end{center}
  \begin{itemize}
  \item[â‡’] relativ langsam,
  \item[] nicht fÃ¼r Hardware-Realisierung geeignet
  \end{itemize}

\item[Frage:]
  Gibt es auch einen Algorithmus ohne reelle Operationen?
\end{description}
\Reached{WS17/18}{01}{2017/10/12}
\Reached{WS18/19}{01}{2018/10/11}


\subsection{Inkrementell mit reeller Rechnung}

FÃ¼r jedes $x âˆˆ \mk{ xâ‚, xâ‚ + 1, â€¦, xâ‚‚}$ sei:

\begin{center}
  \begin{tabular}{ll}
    $\mdef{y(x)} := mx + b$ & der zu $x$ gehÃ¶rige $y$-Wert auf der (exakten) Geraden \\
    $\mdef{\widetilde{y}(x)} := \round(y(x))$ & der $y$-Wert des in Spalte $x$ gewÃ¤hlten Pixels \\
    $\mdef{d(x)} := y(x) - \widetilde{y}(x)$
    & â€um wie viel liegt die Gerade an der Stelle $x$ oberhalb des Pixels?â€œ
  \end{tabular}
\end{center}

\begin{center}
  \scalebox{0.65}{\Large\input{fig_scanStreckeIncrement1}}
\end{center}

\begin{description}
\item[Idee:]
  Berechne $y(x)$ und $\widetilde{y}(x)$ nicht fÃ¼r jeden
  $x$-Wert gemÃ¤ÃŸ der obigen Formeln, sondern bestimme, um wie viel
  sie sich beim Ãœbergang von $x$ zu $x + 1$ Ã¤ndern
  \emph{(â€Inkrementâ€œ)}\index{Inkrement}:
  \begin{align*}
    y(x + 1) &= y(x) + \mdef{Î” y(x)} \\
    \widetilde{y}(x + 1) &= \widetilde{y}(x) + \mdef{Î” \widetilde{y}(x)}
  \end{align*}

\item[Annahme:]
  Im Folgenden sei $m â‰¥ 0$ (also $m \in \ek{0; 1}$).
\end{description}

Es ist
\begin{align*}
  Î” y(x) &= y(x + 1) - y(x) \\
  &= m Â· (x + 1) + b - (m Â· x + b) \\
  &= m \qquad \text{\cmt{unabhÃ¤ngig von $x$}}
\end{align*}
und
\begin{align*}
  y(x + 1) - \widetilde{y}(x) &= y(x) + m - \widetilde{y}(x) \\
  &= d(x) + m \\
  &âˆˆ \ek{-\frac12; \frac32} \qquad \text{\cmt{da $d(x) âˆˆ \ek{-\frac12; \frac12}$
      und $m âˆˆ \ek{0; 1}$}} \,\text.
\end{align*}

\begin{itemize}
\item[â‡’]
  $y(x + 1) âˆˆ \ek{\widetilde{y}(x) - \frac12; \widetilde{y}(x) + \frac32}$

\item[â‡’]
  $\widetilde{y}(x + 1) = \round(y(x + 1)) âˆˆ \mk{\widetilde{y}(x), \widetilde{y}(x) + 1}$

\item[â‡’]
  In Spalte $x + 1$ wird eines der beiden Pixel
  \begin{align*}
    \rk{x + 1, \widetilde{y}(x)} &=: \mdef{\textbf{O} \quad \text{(â€Ã¶stlicher Nachbarâ€œ)}} \\
    \rk{x + 1, \widetilde{y}(x) + 1} &=: \mdef{\textbf{NO} \quad
      \text{(â€nordÃ¶stlicher Nachbarâ€œ)}}
  \end{align*}
  ausgewÃ¤hlt, \dH $Î” \widetilde{y}(x) âˆˆ \mk{0, 1}$.
\end{itemize}
\Reached{WS14/15}{02}{2014/10/16}

\begin{center}
  \scalebox{0.65}{\Large\input{fig_scanStreckeIncrement2}}
\end{center}

Entscheidung fÃ¼r â€Oâ€œ
\begin{itemize}
\item[â‡”]
  O liegt nÃ¤her am Geradenpunkt $\rk{x + 1, y(x + 1)}$ als NO
\item[â‡”]
  $\underbrace{d(x) + m}_{\textstyle\mdef{=: \widetilde{d}(x + 1)}} â‰¤ \frac12$
\end{itemize}

\pagebreak

\begin{algorithmus} \mbox{}
  \label{alg:scanStreckeInkrementellReell}
  \begin{AlgListInline}
    Algorithmus Scan Conversion ÂºfÃ¼rÂº Strecke, inkrementell, reelle Rechnung
    
    $m$ := $\frac{yâ‚‚ - yâ‚}{xâ‚‚ - xâ‚}$
    $\rk{x, \widetilde{y}(x)}$ := $\rk{xâ‚, yâ‚}$
    $d(x)$ := $0$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// Startpixel liegt auf der Geraden
    modifiziere Pixel $\rk{x, \widetilde{y}(x)}$
    fÃ¼r $x = xâ‚ + 1, â€¦, xâ‚‚$
    Â°Â°Â°$\widetilde{d}(x)$ := $d(x - 1) + m$
    Â°Â°Â°wenn $\widetilde{d}(x) \le \frac12$
    Â°Â°Â°Â°Â°Â°$\widetilde{y}(x)$ := $\widetilde{y}(x - 1)$Â°Â°Â°Â°Â°Â°Â°Â°Â°// Entscheidung fÃ¼r â€Oâ€œ
    Â°Â°Â°Â°Â°Â°$d(x)$ := $\widetilde{d}(x)$
    Â°Â°Â°sonst
    Â°Â°Â°Â°Â°Â°$\widetilde{y}(x)$ := $\widetilde{y}(x - 1) + 1$Â°Â°Â°Â°Â°// â€NOâ€œ
    Â°Â°Â°Â°Â°Â°$d(x)$ := $\widetilde{d}(x) - 1$
    Â°Â°Â°modifiziere Pixel $\rk{x, \widetilde{y}(x)}$
  \end{AlgListInline}
\end{algorithmus}

\pagebreak

\begin{bemerkungen} \mbox{}
  \begin{enumerate}
  \item Im Fall $m < 0$ kann auch
    $\widetilde{d}(x) < - \frac12$ vorkommen.
    Dann ist $Î” \widetilde{y}(x) = -1$, also
    \[ \rk{x + 1, \widetilde{y}(x) - 1} =: \mdef{\textbf{SO} \quad
        \text{(â€sÃ¼dÃ¶stlicher Nachbarâ€œ)}} \]
    zu wÃ¤hlen.

  \item $y(x)$ tritt nicht mehr explizit auf.

  \item keine reelle Multiplikation und keine Rundung
    reell â‡ ganzzahlig mehr, aber noch reelle Addition
    und reeller Vergleich
  \end{enumerate}
\end{bemerkungen}


\subsection{Inkrementell mit ganzzahliger Rechnung}

\begin{description}
\item[Idee:]
  Die GrÃ¶ÃŸen $m$, $\widetilde{d}$, $\frac12$ und $d$ in
  Algorithmus~\ref{alg:scanStreckeInkrementellReell} sind
  \emph{rational}; Multiplikation mit dem \emph{Hauptnenner}
  \[ \mdef{H} := 2 Â· \rk{xâ‚‚ - xâ‚} \]
  macht sie ganzzahlig.
\end{description}

\begin{algorithmus}%
  \label{alg:scanStreckeInkrementellGanzzahlig} \mbox{}
  \begin{AlgListInline}
    Algorithmus Scan Conversion ÂºfÃ¼rÂº Strecke, inkrementell, ganzzahlige Rechnung
    // Erinnerung: $m âˆˆ [0; 1]$
    
    $M$ := $2 Â· \rk{yâ‚‚ - yâ‚}$Â°Â°Â°Â°Â°// $= H Â· m$
    $\mathtxtit{Halb}$ := $xâ‚‚ - xâ‚$Â°Â°Â°Â°Â°Â°Â°// $= H Â· \frac12$
    $\mathtxtit{Eins}$ := $2 Â· \mathtxtit{Halb}$Â°Â°Â°Â°Â°Â°// $= H Â· 1$
    $x$ := $xâ‚$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// Startpixel $= \rk{xâ‚, yâ‚}$
    $\widetilde{y}$ := $yâ‚$
    $D$ := $0$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// $= H Â· d(x)$
    modifiziere Pixel $\rk{x, \widetilde{y}}$
    fÃ¼r $x = xâ‚ + 1, â€¦, xâ‚‚$
    Â°Â°Â°$D$ := $D + M$Â°Â°Â°Â°Â°// $D$ enthÃ¤lt jetzt $H Â· \widetilde{d}(x)$
    Â°Â°Â°wenn $D > \mathtxtit{Halb}$
    Â°Â°Â°Â°Â°Â°$\widetilde{y}$ := $\widetilde{y} + 1$Â°Â°Â°Â°Â°// Entscheidung fÃ¼r â€NOâ€œ
    Â°Â°Â°Â°Â°Â°$D$ := $D - \mathtxtit{Eins}$
    Â°Â°Â°modifiziere Pixel $\rk{x, \widetilde{y}}$
  \end{AlgListInline}
\end{algorithmus}

\pagebreak

\begin{bemerkung}
  keine reellen Operationen mehr, nur noch ganzzahlige Additionen
  und Vergleiche
  \begin{itemize}
  \item[â‡’] sehr schnell,

    gut fÃ¼r Hardware-Realisierung geeignet
  \end{itemize}

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_scanStreckeHardware}}
  \end{center}
\end{bemerkung}

\pagebreak


\vspace*{-33mm}
\section{Scan Conversion fÃ¼r Kreislinien}

\begin{description}
\item[Ziel:]
  Modifikation der Pixel in der Pixmap, die dem Kreis um
  $\rk{xâ‚˜, yâ‚˜}$ mit Radius $r$ am nÃ¤chsten liegen
\end{description}

\enlargethispage{7mm}
\begin{bemerkung}
  Es genÃ¼gt, die Pixel $\rk{x, \widetilde{y}}$ im
  \emph{â€NNO-Achtelâ€œ} eines Kreises mit Radius $r$ um den
  \emph{Ursprung} zu erzeugen, denn

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_scanKreisNOAchtel}}%â‚˜
  \end{center}

  durchlÃ¤uft \xfigMagentaIII{$\rk{x, \widetilde{y}}$} die Pixel des
  NNO-Achtels, so liefern die Pixel
  \xfigRed{$\rk{xâ‚˜ Â± x, yâ‚˜ Â± \widetilde{y}}$} und
  \xfigRed{$\rk{xâ‚˜ Â± \widetilde{y}, yâ‚˜ Â± x}$}
  die gesuchte Kreislinie.
\end{bemerkung}

\pagebreak

\vspace*{-19mm}
\begin{description}
\item[Frage:]
  Wie erzeugt man die zum NNO-Achtel gehÃ¶rigen Pixel?
\end{description}


\subsection{Zwei naive Verfahren}

\begin{algorithmus}%
  \label{alg:scanNNOachtelParametrisiert} \mbox{}
  \begin{AlgListInline}
    Algorithmus Scan Conversion ÂºfÃ¼rÂº Kreislinie, naiv via Parametrisierung

    // basiert auf der Parametrisierung $\rk{x(t), y(t)} = \rk{r Â· \cos t, r Â· \sin t}$, $t âˆˆ \ek{\frac{Ï€}{4}; \frac{Ï€}{2}}$, des NNO-Achtels
    wÃ¤hle $Î” t$ so klein, dass keine Âºâ€ÂºLÃ¼ckenÂºâ€œÂº entstehen
    fÃ¼r $t = \frac{Ï€}{2}$ mit Schrittweite $-Î” t$ bis $\frac{Ï€}{4}$
    Â°Â°Â°$\rk{\widetilde{x}(t), \widetilde{y}(t)}$ := $\rk{\round(r Â· \cos t), \round(r Â· \sin t)}$
    Â°Â°Â°modifiziere die acht zu $\rk{\widetilde{x}(t), \widetilde{y}(t)}$ gehÃ¶rigen Pixel
  \end{AlgListInline}
\end{algorithmus}

\vspace*{-11mm}
\begin{bemerkung}
  reelle Rechnung, zwei Rundungen reell â‡ ganzzahlig, \emph{sin}, \emph{cos}
  \begin{itemize}
  \item[â‡’] langsam,

    nicht fÃ¼r Hardware-Realisierung geeignet
  \end{itemize}
\end{bemerkung}

\pagebreak

\vspace*{-24mm}
\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus Scan Conversion ÂºfÃ¼rÂº Kreislinie, naiv via Funktionsdarstellung

    // basiert auf der Darstellung $y = \sqrt{rÂ² - xÂ²}$, $x âˆˆ \ek{-r; r}$, des oberen Halbkreises
    $x$ := $0$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// Startpunkt $(0, r)$
    $\widetilde{y}$ := $r$
    solange $\widetilde{y} â‰¥ x$ istÂ°Â°Â°Â°Â°// noch im NNO-Achtel
    Â°Â°Â°modifiziere die acht zu $\rk{x, \widetilde{y}}$ gehÃ¶rigen Pixel
    Â°Â°Â°$x$ := $x + 1$
    Â°Â°Â°$\widetilde{y}$ := $\round\rk{\sqrt{rÂ² - xÂ²}}$
  \end{AlgListInline}
\end{algorithmus}

\begin{bemerkung}
  reelle Rechnung, Rundung reell â‡ ganzzahlig, \emph{Wurzel}
  \begin{itemize}
  \item[â‡’] relativ langsam (aber schneller als
    Algorithmus~\ref{alg:scanNNOachtelParametrisiert}),

    nicht fÃ¼r Hardware-Realisierung geeignet
  \end{itemize}
\end{bemerkung}

\begin{description}
\item[Frage:]
  Gibt es auch fÃ¼r Kreislinien einen inkrementellen Ansatz
  (wenn mÃ¶glich ganzzahlig)?
\end{description}


\subsection{Ein inkrementeller Ansatz}

FÃ¼r alle $x$-Werte $x = 0, 1, â€¦$ sei wieder

\begin{center}
  \begin{tabular}{Ll}
    \rk{x, \mdef{y(x)}} & der zugehÃ¶rige Punkt auf der Kreislinie und \\
    \rk{x, \mdef{\widetilde{y}(x)}} & das entsprechende Pixel.
  \end{tabular}
\end{center}

\begin{center}
  \scalebox{0.65}{\Large\input{fig_scanKreisIncrement}}
\end{center}

Ausgehend von Pixel $\rk{x, \widetilde{y}(x)}$ wird von den
beiden Pixeln
\begin{align*}
  \rk{x + 1, \widetilde{y}(x)} &= \textbf{O} \quad \text{(Ã¶stlicher Nachbar)} \\
  \rk{x + 1, \widetilde{y}(x) - 1} &= \textbf{SO} \quad \text{(sÃ¼dÃ¶stlicher Nachbar)}
\end{align*}
das gewÃ¤hlt, welches nÃ¤her an dem Punkt
$\rk{x + 1, y(x + 1)}$ auf der Kreislinie liegt.

\begin{align*}
  &\rk{x + 1, y(x + 1)} \text{ liegt nÃ¤her bei SO als bei O} \\
  &â‡” y(x + 1) < \widetilde{y}(x) - \frac12 \\
  &â‡” yÂ² (x + 1) < \rk{\widetilde{y}(x) - \frac12}Â² \qquad
  \text{\cmt{NNO-Achtel!}} \\
  &â‡” rÂ² - (x + 1)Â² < \rk{\widetilde{y}(x) - \frac12}Â² \\
  &â‡” \mymagenta{\underbrace{\black{rÂ² - xÂ²}}} - 2x - 1
  < \widetilde{y}Â²(x) - \widetilde{y}(x) + \frac14 \\
  &â‡” \mymagenta{yÂ²(x)} - \widetilde{y}Â²(x) + \widetilde{y}(x) - 2x - \frac54 < 0
\end{align*}

\begin{description}
\item[Also:]
  Setze
  \[ \mdef{d(x)} := yÂ²(x) - \widetilde{y}Â²(x) + \widetilde{y}(x) - 2x - \frac54 \]
  und wÃ¤hle als nÃ¤chstes Pixel
  \begin{center}
    \begin{tabular}{ll}
      O,  & falls $d(x) â‰¥ 0$ \\
      SO, & falls $d(x) < 0$.
    \end{tabular}
  \end{center}

\item[Frage:]
  Kann auch $d$ \emph{inkrementell} berechnet werden, also
  $d(x + 1)$ aus $d(x)$?

  \pagebreak

\item[Fall 1:] Entscheidung fÃ¼r O, \dH
  $\widetilde{y}(x + 1) = \widetilde{y}(x)$
  
  Dann ist
  \begin{align*}
    d(x + 1)
    &= \mymagenta{\underbrace{\black{yÂ²(x + 1)}}}
    - \mygreen{\underbrace{\black{\widetilde{y}Â²(x + 1)}}}
    + \mygreen{\underbrace{\black{\widetilde{y}(x + 1)}}}
    - 2 (x + 1) - \frac54 \\
    &= \mymagenta{rÂ² - (x + 1)Â²} - \mygreen{\widetilde{y}Â²(x)}
    + \mygreen{\widetilde{y}(x)} - 2 (x + 1) - \frac54 \\
    &= \mymagenta{\underbrace{\black{rÂ² - xÂ²}}} - 2x - 1 - \widetilde{y}Â²(x)
    + \widetilde{y}(x) - 2x - 2 - \frac54 \\
    &= \mygreen{\underbrace{\black{\mymagenta{yÂ²(x)} - \widetilde{y}Â²(x)
          + \widetilde{y}(x) - 2x - \frac54}}} - 2x - 3 \\
    &= \mygreen{d(x)} - (2(x + 1) + 1) \,\text.
  \end{align*}

  \pagebreak

\item[Fall 2:] Entscheidung fÃ¼r SO, \dH
  $\widetilde{y}(x + 1) = \widetilde{y}(x) - 1$

  Dann ist
  \begin{align*}
    d(x + 1) &= \mymagenta{\underbrace{\black{yÂ²(x + 1)}}}
    - \mygreen{\underbrace{\black{\widetilde{y}Â²(x + 1)}}}
    + \mygreen{\underbrace{\black{\widetilde{y}(x + 1)}}}
    - 2 (x + 1) - \frac54 \\
    &= \mymagenta{rÂ² - (x + 1)Â²} - \mygreen{\rk{\widetilde{y}(x) - 1}Â²}
    + \mygreen{\widetilde{y}(x) - 1} - 2 (x + 1) - \frac54 \\
    &= \mymagenta{\underbrace{\black{rÂ² - xÂ²}}} - 2x - 1 - \widetilde{y}Â²(x)
    + 2 \widetilde{y}(x) - 1 + \widetilde{y}(x) - 1 - 2x - 2 - \frac54 \\
    &= \mygreen{\underbrace{\black{\mymagenta{yÂ²(x)} - \widetilde{y}Â²(x)
          + \widetilde{y}(x) - 2x - \frac54}}} + 2 \widetilde{y}(x) - 2x - 5 \\
    &= \mygreen{d(x)} - \rk{2 \rk{(x + 1)
        - \mymagenta{\underbrace{\black{\rk{\widetilde{y}(x) - 1}}}}} + 1} \\
    &= d(x) - \rk{2 \rk{(x + 1) - \mymagenta{\widetilde{y}(x + 1)}} + 1} \,\text.
  \end{align*}
\end{description}

\pagebreak

\vspace*{-19mm}
\begin{algorithmus}%
  \label{alg:scanNNOachtelInkrementellReell} \mbox{}
  \begin{AlgListInline}
    Algorithmus Scan Conversion ÂºfÃ¼rÂº Kreislinie, inkrementell, reelle Rechnung

    // basiert auf der Kreisgleichung $yÂ² = rÂ² - xÂ²$
    $x$ := $0$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// Startpunkt $(0, r)$
    $\widetilde{y}$ := $r$
    $d$ := $r - \frac54$ Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// $= d(0)$
    solange $\widetilde{y} â‰¥ x$ istÂ°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// noch im NNO-Achtel
    Â°Â°Â°modifiziere die acht zu $\rk{x, \widetilde{y}}$ gehÃ¶rigen Pixel
    Â°Â°Â°$x$ := $x + 1$
    Â°Â°Â°wenn $d â‰¥ 0$
    Â°Â°Â°Â°Â°Â°$d$ := $d - (2x + 1)$Â°Â°Â°Â°Â°Â°Â°Â°Â°// Entscheidung fÃ¼r O
    Â°Â°Â°sonst
    Â°Â°Â°Â°Â°Â°$\widetilde{y}$ := $\widetilde{y} - 1$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// Entscheidung fÃ¼r SO
    Â°Â°Â°Â°Â°Â°$d$ := $d - \rk{2 \rk{x - \widetilde{y}} + 1}$
  \end{AlgListInline}
\end{algorithmus}

\begin{bemerkung}
  Algorithmus~\ref{alg:scanNNOachtelInkrementellReell} kann (fÃ¼r
  ganzzahlige $r$, $xâ‚˜$ und $yâ‚˜$) in einen
  \emph{inkrementellen ganzzahligen} Algorithmus Ã¼berfÃ¼hrt werden.
\end{bemerkung}


\section{Scan Conversion fÃ¼r Polygone}

\begin{description}
\item[gegeben:] ein Polygon $P$ in der Ebene

\item[gesucht:] die dem Polygon entsprechenden Pixel
\end{description}

\begin{center}
  \includegraphics{fig_scanPolygonPrinzip}
\end{center}

\pagebreak


\subsection{Polygone}

Ein \emph{geschlossener einfacher Polygonzug}\index{Polygonzug!geschlossener einfacher}
$\mdef{Z} = \rk{sâ‚, sâ‚‚, â€¦, sâ‚—}$ ist eine Folge von
\emph{Kanten}\index{Kante} (gerichteten Strecken)
$sáµ¢ = \overrightarrow{\point{P}áµ¢â‚‹â‚ \point{P}áµ¢}$, so dass
\begin{itemize}
\item $\point{P}â‚€ = \point{P}â‚—$
\item $sáµ¢$ hat mit $sáµ¢â‚Šâ‚$ den Punkt $\point{P}áµ¢$ gemeinsam
  (sowie $sâ‚—$ mit $sâ‚$ den Punkt $\point{P}â‚—$);

  weitere Schnittpunkte der Strecken gibt es nicht.
\end{itemize}

\begin{center}
  \scalebox{0.6}{\LARGE\input{fig_scanPolygonzug}}%â‚â‚‚â‚ƒâ‚„â‚…
\end{center}

\pagebreak

Ein \emph{Polygon}\index{Polygon} ist definiert durch $m â‰¥ 1$ geschlossene einfache
PolygonzÃ¼ge $Zâ‚, â€¦, Zâ‚˜$, die untereinander (als Punktmengen
in der Ebene) disjunkt sind.
Wird der Kantenzug $Zâ±¼ = \rk{sâ‚â½Ê²â¾, â€¦, s_{lâ±¼}â½Ê²â¾}$
in dieser Reihenfolge durchlaufen, so liegt das
\emph{Innere}\index{Polygon!Inneres}\index{Inneres eines Polygons}
des Polygons \emph{links} jeder der gerichteten Strecken $sáµ¢â½Ê²â¾$.

Die Punkte $\point{P}áµ¢â½Ê²â¾$ heiÃŸen
\emph{Ecken}\index{Polygon!Ecke}\index{Ecke eines Polygons}
des Polygons.

Ein Polygon heiÃŸt
\emph{einfach}\index{Polygon!einfaches}\index{einfaches Polygon},
wenn es durch einen einzigen Polygonzug definiert wird.

\begin{beispiel} \mbox{}
  \begin{Hide}
    \begin{center}
      \scalebox{0.6}{\LARGE\input{fig_scanPolygone}}
    \end{center}
  \end{Hide}
\end{beispiel}

\pagebreak


\vspace*{-25mm}
\subsection{Der Grundalgorithmus}%
\label{subsec:scanConversionPolygoneGrundalgorithmus}

\begin{description}
\item[Beobachtung:]
  Die Pixel auf jeder horizontalen (oder vertikalen) Linie
  \emph{(â€Scan Lineâ€œ)}\index{Scan Line} bilden eine oder mehrere Folgen
  aufeinander folgender Pixel \emph{(â€Spansâ€œ)}\index{Span}.

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_scanPolygonGrundalgorithmus}}
  \end{center}

  Jede solche Span wird durch zwei Schnittpunkte der Scan Line
  mit dem \emph{Rand} des Polygons begrenzt.
\end{description}

LÃ¤uft man auf der Scan Line von links ($x = -âˆ$) nach rechts
($x = +âˆ$), so entspricht jeder Schnittpunkt mit einer
Polygonkante einem Wechsel vom Ã„uÃŸeren ins Innere des Polygons und
umgekehrt.

\begin{itemize}
\item[â‡’] Ordnet man die Schnittpunkte $\point{S}â±¼$ der
  Polygonkanten mit der Scan Line nach aufsteigenden $x$-Werten an,
  so folgt:
  \begin{itemize}
  \item Span 1 liegt zwischen $\point{S}â‚$ und $\point{S}â‚‚$.
  \item Span 2 liegt zwischen $\point{S}â‚ƒ$ und $\point{S}â‚„$.
  \item â€¦
  \end{itemize}
\end{itemize}

\begin{bemerkung}
  Die Ecken des Polygons und seine horizontalen Kanten mÃ¼ssen
  gesondert behandelt werden:

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_scanPolygonSonderfaelle}}
  \end{center}

  \begin{enumerate}
  \item[I] unterer Endpunkt der einen, oberer Endpunkt der anderen
    Kante
    \begin{itemize}
    \item[â‡’] nur einmal zÃ¤hlen
    \end{itemize}

  \item[II] unterer (oder oberer) Endpunkt beider Kanten
    \begin{itemize}
    \item[â‡’] zweimal (oder gar nicht) zÃ¤hlen
    \end{itemize}

  \item[III] gemeinsame Ecke einer horizontalen mit einer nicht
    horizontalen Kante
    \begin{itemize}
    \item[â‡’] nur einmal zÃ¤hlen
    \end{itemize}
  \end{enumerate}
\end{bemerkung}

\pagebreak

\vspace*{-23mm}
\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus Scan Conversion ÂºfÃ¼rÂº Polygone, Grundalgorithmus

    // bestimme den Laufbereich fÃ¼r die Scan Line
    bestimme unter den Ecken von $P$ die minimale und maximale $y$-Koordinate $y_{\min}$ und $y_{\max}$
    // laufe mit der Scan Line Ã¼ber das Polygon
    fÃ¼r $y = y_{\min}, â€¦, y_{\max}$
    Â°Â°Â°fÃ¼r alle Seiten des Polygons
    Â°Â°Â°Â°Â°Â°prÃ¼fe, ob die Scan Line die Seite schneidet und berechne ggf. den Schnittpunkt
    Â°Â°Â°sortiere die Schnittpunkte mit der Scan Line nach aufsteigenden $x$-Werten
    Â°Â°Â°entferne einige der doppelten Schnittpunkte gemÃ¤ÃŸ der obigen Bemerkung
    Â°Â°Â°// nun seien noch $\point{S}â‚, â€¦, \point{S}â‚–$ mit $xâ‚ â‰¤ â€¦ â‰¤ xâ‚–$ Ã¼brig
    Â°Â°Â°fÃ¼r $i = 1, â€¦, \frac{k}{2}$
    Â°Â°Â°Â°Â°Â°modifiziere die Pixel der Span $\rk{\round\fk{xâ‚‚áµ¢â‚‹â‚}, y}$, â€¦, $\rk{\round\fk{xâ‚‚áµ¢}, y}$
  \end{AlgListInline}
\end{algorithmus}

\begin{bemerkung}
  FÃ¼r die Modifikation der Pixel einer Span gibt es \iA effizientere Methoden als
  Algorithmus~\ref{alg:scanStreckeInkrementellGanzzahlig}.
\end{bemerkung}

\pagebreak

\begin{description}
\item[Aufwand:]
  Sei

  \begin{center}
    \begin{tabular}{Ll}
      \mdef{n} & die Anzahl der Ecken \bzw Kanten von $P$ und \\
      \mdef{l} = y_{\max} - y_{\min} + 1 & die Anzahl der Ã¼ber das
      Polygon gelegten Scan Lines.
    \end{tabular}
  \end{center}

  Dann betrÃ¤gt der â€Verwaltungsaufwandâ€œ des Algorithmus
  \emph{(ohne die eigentliche Pixelmodifikation)}:

  \begin{tabular}{ll}
    & $ğ’ª(n)$ Operationen zur Bestimmung von $y_{\min}$, $y_{\max}$ \\
    & $l$-mal: \\
    & \qquad $n$ Schnitttests \bzw Schnittpunktberechnungen \\
    & \qquad $ğ’ª(n \log n)$ Operationen fÃ¼r das Sortieren der $ğ’ª(n)$ Schnittpunkte \\ \hline
    $âˆ‘$: & \myred{$l Â· n$ Schnitttests/Schnittpunktberechnungen} \\
    & \myred{$ğ’ª(l Â· n \log n)$ sonstige Operationen}
  \end{tabular}
\end{description}

\pagebreak


\vspace*{-28mm}
\subsection{Ein inkrementeller Ansatz}

\begin{description}
\item[Idee:]
  nicht die einzelnen Pixel inkrementell berechnen, sondern die
  Ausdehnung der \emph{Spans}

  \begin{center}
    \scalebox{0.75}{\Large\input{fig_scanPolygonInkrementell1}}%â‚â‚‚
  \end{center}

\item[Beobachtung:]
  Beim Ãœbergang von einer Scan Line zur nÃ¤chsten kann der
  \emph{Schnittpunkt} mit jeder Polygonseite \emph{inkrementell}
  berechnet werden: Ist

  \begin{center}
    \begin{tabular}{Ll}
      \mdef{m} & die Steigung der Strecke und \\
      \rk{\mdef{x(y)}, y} & ihr Schnittpunkt mit der Scan Line $y$,
    \end{tabular}
  \end{center}

  so ist
  \[ \rk{x(y + 1), y + 1} = \rk{x(y) + \frac{1}{m}, y + 1} \]
  ihr Schnittpunkt mit der nÃ¤chsten Scan Line $y + 1$.
\end{description}

\enlargethispage{5mm}
\begin{bemerkung}
  Dies funktioniert natÃ¼rlich nur, wenn die Strecke bereits die vorige
  Scan Line geschnitten hat.
\end{bemerkung}

\pagebreak

Strecke $s$ heiÃŸt \emph{aktiv}\index{aktive Strecke}\index{Strecke!aktive} bei
Scan Line $y$, wenn sie die Scan Line schneidet.

\begin{center}
  \scalebox{0.7}{\Large\input{fig_scanPolygonInkrementell2}}%â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰
\end{center}

aktive Strecken bei Scan Line
\begin{center}
  \begin{tabular}{lCCCCCCCCC}
    $y + 5$: & sâ‚ &&& sâ‚â‚€ & sâ‚‰& & sâ‚… & sâ‚†& sâ‚‡ \\
    $y + 4$: & sâ‚ & sâ‚‚ & sâ‚ƒ & sâ‚â‚€ & sâ‚‰ && sâ‚… & sâ‚† & sâ‚‡ \\
    $y + 3$: & sâ‚ & sâ‚‚ & sâ‚ƒ & sâ‚â‚€ & sâ‚‰ && sâ‚… & sâ‚† & sâ‚‡ \\
    $y + 2$: & sâ‚ & sâ‚‚ & sâ‚ƒ &&& sâ‚„ & sâ‚… & sâ‚† & sâ‚‡ \\
    $y + 1$: & sâ‚ & sâ‚‚ & sâ‚ƒ &&& sâ‚„ && sâ‚† & sâ‚‡ \\
    $y$: & sâ‚ & sâ‚‚ &&&&&& sâ‚† & sâ‚‡ \\
  \end{tabular}
\end{center}

\pagebreak

\vspace*{-17mm}
\begin{description}
\item[Beobachtungen:] \mbox{}
  
  \begin{itemize}
  \item Eine Strecke wird aktiv, sobald die Scan Line ihren
    \emph{unteren} Endpunkt trifft;
    
    sie wird inaktiv, wenn die Scan Line ihren \emph{oberen} Endpunkt
    passiert hat.
    
  \item \emph{Ordnet} man die aktiven Strecken \bzgl ihres
    Schnittpunkts mit der Scan Line, so bleibt diese Ordnung beim
    Ãœbergang zur nÃ¤chsten Scan Line erhalten.
  \end{itemize}
  
\item[Verwaltung der aktiven Strecken:] \mbox{}
  
  \[ \mathtxtit{Aktiv} = \rk{(\underbrace{iâ‚}_{\myred{\small\makebox(0,0)[tr]{%
            Nummer der Strecke}}},
      \underbrace{xâ‚}_{\myred{\small\makebox(0,0)[tl]{%
            $x$-Koordinate des Schnittpunkts der Scan Line mit Strecke $iâ‚$}}}),
      (iâ‚‚, xâ‚‚), â€¦, (iâ‚–, xâ‚–)} \,\text, \Bigskip \]
  sortiert nach aufsteigenden $x$-Werten
\end{description}

\begin{bemerkung}
  Werden gleichzeitig zwei Strecken mit gleichem unterem Endpunkt
  aktiv, so mÃ¼ssen sie nach
  $\mdef{Î” x} := \frac{1}{m}$ sortiert in
  $\mathtxtit{Aktiv}$ eingefÃ¼gt werden, da die Strecke mit kleinerem $Î” x$ auf
  der \emph{nÃ¤chsten} Scan Line zuerst kommt:

  \begin{center}
    \scalebox{0.7}{\Large\input{fig_scanPolygonInkrementell3}}
  \end{center}
\end{bemerkung}

\pagebreak

\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus Scan Conversion ÂºfÃ¼rÂº Polygone, inkrementell

    // Strecke $sáµ¢$ habe die Endpunkte $\rk{x_{i,1}, y_{i,1}}$ und $\rk{x_{i,2}, y_{i,2}}$;
    // dabei sei o.@\,@B.@\,@d.@\,@A. $y_{i,1} â‰¤ y_{i,2}$
    // @\raisebox{0.5ex}{\rule{6em}{1pt}}@ Vorverarbeitung @\raisebox{0.5ex}{\rule{6em}{1pt}}@
    fÃ¼r $i = 1, â€¦, n$
    Â°Â°Â°berechne $Î” xáµ¢$ := $\frac{x_{i,2} - x_{i,1}}{y_{i,2} - y_{i,1}}$ ($= \frac{1}{máµ¢}$)
    // Laufbereich der Scan Line
    bestimme unter den Ecken von $P$ die minimale und die maximale $y$-Koordinate $y_{\min}$ bzw. $y_{\max}$
    // bestimme zu jeder Scan Line $y$ die Mengen
    // $\mathtxtit{wird\_aktiv}(y)$ bzw. $\mathtxtit{wird\_inaktiv}(y)$ der dort aktiv bzw. inaktiv werdenden Strecken
    fÃ¼r $y = y_{\min}, â€¦, y_{\max}$
    Â°Â°Â°$\mathtxtit{wird\_aktiv}(y)$ := $âˆ…$
    Â°Â°Â°$\mathtxtit{wird\_inaktiv}(y)$ := $âˆ…$
    fÃ¼r $i = 1, â€¦, n$
    Â°Â°Â°fÃ¼ge $i$ in $\mathtxtit{wird\_aktiv}\fk{y_{i,1}}$ und $\mathtxtit{wird\_inaktiv}\fk{y_{i,2}}$ ein
  \end{AlgListInline}

  \begin{AlgListInline}
    // @\raisebox{0.5ex}{\rule{6em}{1pt}}@ laufe nun mit der Scan Line Ã¼ber $P$ @\raisebox{0.5ex}{\rule{6em}{1pt}}@
    $\mathtxtit{Aktiv}$ := $âˆ…$
    fÃ¼r $y$ := $y_{\min}, â€¦, y_{\max}$
    Â°Â°Â°// zuerst die aktiv gewordenen Strecken einordnen
    Â°Â°Â°fÃ¼r alle $i âˆˆ \mathtxtit{wird\_aktiv}(y)$
    Â°Â°Â°Â°Â°Â°falls es in $\mathtxtit{wird\_inaktiv}(y)$ ein Element $j$ gibt mit $x_{i,1} = x_{j,2}$Â°Â°Â°Â°Â°@\makebox(0,0)[l]{\scalebox{0.5}{\LARGE\input{fig_scanPolygonInkrementellAlgo1}}}@
    Â°Â°Â°Â°Â°Â°Â°Â°Â°ersetze $\rk{j, x_{j,2}}$ in $\mathtxtit{Aktiv}$ durch $\rk{i, x_{i,1}}$
    Â°Â°Â°Â°Â°Â°Â°Â°Â°entferne $j$ aus $\mathtxtit{wird\_inaktiv}(y)$
    Â°Â°Â°Â°Â°Â°sonstÂ°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°@\makebox(0,0)[l]{\scalebox{0.5}{\LARGE\input{fig_scanPolygonInkrementellAlgo2}}}@
    Â°Â°Â°Â°Â°Â°Â°Â°Â°fÃ¼ge $\rk{i, x_{i,1}}$ bzgl. $x$ (und ggf. $Î” x$) sortiert in $\mathtxtit{Aktiv}$ ein
    Â°Â°Â°// die Spans zwischen den aktiven Strecken zeichnen;
    Â°Â°Â°// sei $\mathtxtit{Aktiv} = \rk{\rk{iâ‚, x_{iâ‚}}, \rk{iâ‚‚, x_{iâ‚‚}}, â€¦, \rk{iâ‚–, x_{iâ‚–}}}$
    Â°Â°Â°modifiziere die Pixel der Spans $\rk{\round\fk{x_{iâ‚‚â±¼â‚‹â‚}}, y}$, â€¦, $\rk{\round\fk{x_{iâ‚‚â±¼}}, y}$, $j = 1, â€¦, \frac{k}{2}$
    Â°Â°Â°// entferne die inaktiv gewordenen Strecken
    Â°Â°Â°fÃ¼r alle $j âˆˆ \mathtxtit{wird\_inaktiv}(y)$
    Â°Â°Â°Â°Â°Â°entferne $\rk{j, x_{j,2}}$ aus $\mathtxtit{Aktiv}$
    Â°Â°Â°// berechne fÃ¼r die Ã¼brigen inkrementell den Schnittpunkt mit der nÃ¤chsten Scan Line
    Â°Â°Â°fÃ¼r alle $\rk{i, xáµ¢} âˆˆ \mathtxtit{Aktiv}$
    Â°Â°Â°Â°Â°Â°$xáµ¢$ := $xáµ¢ + Î” xáµ¢$
  \end{AlgListInline}
\end{algorithmus}%áµ¢â±¼

\pagebreak

\begin{description}
\item[Aufwand:]
  Sei wieder

  \begin{center}
    \begin{tabular}{Ll}
      \mdef{n} & die Anzahl der Ecken \bzw Kanten von $P$ und \\
      \mdef{l} = y_{\max} - y_{\min} + 1 & die Anzahl der Scan Lines.
    \end{tabular}
  \end{center}

  \begin{tabular}{ll}
    $Î” xáµ¢$, $y_{\min}$, $y_{\max}$ berechnen: & $ğ’ª(n)$ \\
    $\mathtxtit{wird\_aktiv}$, $\mathtxtit{wird\_inaktiv}$ belegen: & $ğ’ª(n + l)$ \\
    $l$-mal: \\
    \qquad $\frac{k}{2}$ Spans zeichnen: & â€” \\
    $n$-mal: \\
    \qquad Eintrag in $\mathtxtit{wird\_inaktiv}$ suchen, \ggf lÃ¶schen: & je $ğ’ª(n)$ \\
    \qquad Eintrag in $\mathtxtit{Aktiv}$ einfÃ¼gen \bzw einen alten Eintrag ersetzen: &
    je $ğ’ª(n)$ \\
    \qquad Eintrag aus $\mathtxtit{Aktiv}$ lÃ¶schen: & je $ğ’ª(n)$ \\
    $ğ’ª(n Â· l)$-mal: \\
    \qquad $x$-Wert eines $\mathtxtit{Aktiv}$-Eintrags Ã¤ndern: & je $ğ’ª(1)$ \\ \hline
    gesamter Verwaltungsaufwand:
    \myred{$ğ’ª(n Â· (n + l))$}
  \end{tabular}

  (\emph{keine Schnittpunktberechnungen} mehr!)
\end{description}

\pagebreak

\begin{bemerkungen} \mbox{}
  \begin{enumerate}
  \item FÃ¼r die Aufwandsanalyse wurde angenommen, dass
    $\mathtxtit{Aktiv}$, $\mathtxtit{wird\_aktiv}$ und $\mathtxtit{wird\_inaktiv}$
    mit Feldern implementiert sind.

    Bei Verwendung geeigneter Datenstrukturen kann der
    Verwaltungsaufwand auf
    \myred{$ğ’ª(n Â· (\log n + l))$} reduziert werden.

  \item Im Algorithmus fehlt die Behandlung horizontaler Kanten.
    \begin{itemize}
    \item einfachste LÃ¶sung: gar nicht berÃ¼cksichtigen
    \item Folge: â€Obereâ€œ horizontale Kanten werden nicht gemalt.
    \end{itemize}


  \item FÃ¼r \emph{konvexe} Polygone wird der Algorithmus wesentlich
    einfacher.
  \end{enumerate}
\end{bemerkungen}
\Reached{WS15/16}{02}{2015/10/29}
\Reached{WS16/17}{02}{2016/10/27}
\Reached{WS19/20}{02}{2019/10/17}

\pagebreak


\subsection{Der Flood Fill Algorithmus}

\begin{description}
\item[Idee:]
  Zeichne zuerst den Rand des Objekts und fÃ¼lle dann das Innere
  aus:

  \begin{center}
    \scalebox{0.7}{\huge\input{fig_scanPolygonFloodFill1}}
  \end{center}
\end{description}

\pagebreak

\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus Flood Fill

    zeichne den Rand des Objekts
    wÃ¤hle ein Pixel $(x, y)$ im Innern des Objekts
    fill($x$, $y$)
  \end{AlgListInline}
\end{algorithmus}

\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus fill($x$, $y$)
    // rekursive FÃ¼ll-Funktion

    wenn Pixel $(x, y)$ noch nicht den gewÃ¼nschten Wert hat
    Â°Â°Â°modifiziere Pixel $(x, y)$
    Â°Â°Â°fill($x + 1$, $y$)Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// Nachbarpunkte
    Â°Â°Â°fill($x$, $y + 1$)
    Â°Â°Â°fill($x - 1$, $y$)
    Â°Â°Â°fill($x$, $y - 1$)
  \end{AlgListInline}
  \ReachedZoom{WS20/21}{02}{2020/11/05}
\end{algorithmus}

\pagebreak

\vspace*{-21mm}
\begin{bemerkungen} \mbox{}
  \begin{enumerate}
  \item[\Good] schnell

  \item[\Good] sehr einfach, auch fÃ¼r Hardware-Realisierung geeignet

  \item[\Good] erlaubt das FÃ¼llen nahezu beliebiger Konturen

    \begin{center}
      \includegraphics[scale=0.7]{fig_scanPolygonFloodFill2}
    \end{center}

  \item[\Bad] Objekte der gleichen Farbe kÃ¶nnen nicht â€Ã¼bermaltâ€œ werden

  \item[\Bad] Der Rand darf keine LÃ¼cken enthalten (\zB nicht â€gestricheltâ€œ gezeichnet).

  \item[\Bad] arbeitet (zumindest in der angegebenen â€“ vereinfachten â€“
    Version) nicht immer korrekt:

    \begin{center}
      \scalebox{0.7}{\Large\input{fig_scanPolygonFloodFill3}}
    \end{center}
  \end{enumerate}
  \Reached{WS17/18}{02}{2017/10/19}
\end{bemerkungen}

\pagebreak


\section{Nochmals: Strecken und Kreise}

\subsection{Linien vorgegebener â€Strichbreiteâ€œ}

\begin{description}
\item[Problem:]
  Wie zeichnet man eine Strecke/Kreislinie, die $d$ Pixel breit ist?

\item[Ansatz 1:]
  Eine $d$ Pixel breite Strecke ist ein Rechteck, also ein Polygon.

  \begin{itemize}
  \item[â‡’] Berechne die vier Eckpunkte des Polygons und
    fÃ¼hre dann Scan Conversion fÃ¼r das Polygon durch.
  \end{itemize}

  \begin{center}
    \includegraphics[scale=0.7]{fig_scanBreiteStrecke1}
  \end{center}

  \pagebreak

  \vspace*{-20mm}
\item[Ansatz 2:]
  Erzeuge inkrementell die der Strecke am nÃ¤chsten liegenden Pixel.

  Modifiziere aber nicht nur diese, sondern einen ganzen Bereich
  um sie herum \emph{(â€Malen mit einem dickeren Pinselâ€œ)}.

  \begin{itemize}
  \item quadratische Pinselform:

    \vspace*{-5mm}
    \begin{center}
      \scalebox{0.6}{\Large\input{fig_scanBreiteStrecke2}}
    \end{center}

    \begin{description}
    \item[Problem:] Die tatsÃ¤chliche Strichbreite und die Form
      der Strecken-Enden hÃ¤ngen von der Steigung der Strecke
      ab:

      \vspace*{-5mm}
      \begin{center}
        \scalebox{0.6}{\Large\input{fig_scanBreiteStrecke3}}%â‰ˆ
      \end{center}

    \item[GegenmaÃŸnahme:] Korrektur der Pinselbreite in
      AbhÃ¤ngigkeit von der Steigung

      oder
    \end{description}

  \item kreisfÃ¶rmiger Pinsel:

    \begin{center}
      \scalebox{0.6}{\Large\input{fig_scanBreiteStrecke4}}%â‰ˆ
    \end{center}

    TatsÃ¤chliche Strichbreite und Form der Strecken-Enden sind
    (nahezu) \emph{unabhÃ¤ngig von der Steigung}.
  \end{itemize}
\end{description}


\subsection{Unterbrochene Linien}

\begin{description}
\item[Problem:]
  Wie zeichnet man eine â€gestrichelteâ€œ oder â€gestrichpunkteteâ€œ Linie?

  \begin{center}
    \includegraphics[scale=0.7]{fig_scanStreckeMuster1}
  \end{center}

\item[Ansatz 1:]
  Erzeuge eine \emph{Maske}\index{Maske} fÃ¼r die Periode des Musters:

  \begin{center}
    \scalebox{0.7}{\large\input{fig_scanStreckeMuster2}}
  \end{center}

  Verwende einen inkrementellen Algorithmus zur Scan Conversion,
  oder \emph{zÃ¤hle} die davor generierten Pixel mit (beginnend mit
  Nummer $i = 0$).

  Modifiziere das $i$-te Pixel nur dann, wenn
  \[ mask[i \bmod \text{MaskenlÃ¤nge}] = 1 \,\text. \]

  \pagebreak

  \vspace*{-21mm}
  \begin{description}
  \item[Problem:] Die LÃ¤nge der einzelnen Striche hÃ¤ngt von der
    Steigung der Strecke ab:

    \begin{center}
      \scalebox{0.6}{\Large\input{fig_scanStreckeMuster3}}%â‰ˆ
    \end{center}

  \item[Abhilfe:] steigungsabhÃ¤ngige LÃ¤nge der Maske
  \end{description}

  oder

\item[Ansatz 2:]
  Berechne die LÃ¤nge und die Lage der \emph{einzelnen Striche} und
  fÃ¼hre fÃ¼r jeden einzelnen Strich die Scan Conversion durch.
\end{description}

\begin{bemerkung}
  Beide Verfahren kÃ¶nnen auch fÃ¼r Strichbreite $d > 1$ verwendet
  werden.
  \Reached{WS14/15}{03}{2014/10/23}
  \Reached{WS21/22}{02}{2021/10/21}
\end{bemerkung}


\section{RÃ¤umliche und farbliche Auf\/lÃ¶sung}

\subsection{RÃ¤umliche Auf\/lÃ¶sung statt farblicher Auf\/lÃ¶sung}

\begin{description}
\item[Problem:]
  Wie reduziert man die \emph{â€Stufenâ€œ} bei (gekrÃ¼mmten oder
  geraden) Linien?

  \begin{center}
    \includegraphics[scale=0.65]{fig_scanRaumStattFarbe1}
  \end{center}

\item[Idee:]
  Die Stufen wÃ¤ren sicher weniger auf\/fallend, wenn die Pixmap eine
  hÃ¶here rÃ¤umliche Auf\/lÃ¶sung (\dH mehr Pixel pro FlÃ¤cheninhalt)
  hÃ¤tte.

  \begin{itemize}
  \item[â‡’] Unterteile jedes vorhandene Pixel in
    \mdef{$nâ‚“ Ã— n_y$}
    \emph{â€virtuelle Pixelâ€œ}\index{virtuelles Pixel}\index{Pixel!virtuelles}
    und fÃ¼hre die Scan Conversion mit dieser
    \emph{virtuellen Pixmap}\index{virtuelle Pixmap}\index{Pixmap!virtuelle}
    durch.
  \end{itemize}

  \begin{center}
    \includegraphics[scale=0.65]{fig_scanRaumStattFarbe2}
  \end{center}

  Bestimme, welcher Anteil jedes (groÃŸen) Pixels von der Linie
  Ã¼berdeckt wird:

  \begin{center}
    \scalebox{0.65}{\Large\input{fig_scanRaumStattFarbe3}}
  \end{center}

  Belege jedes Pixel mit einer Helligkeitsstufe, die seinem
  â€Ãœberdeckungsanteilâ€œ entspricht.
\end{description}
\Reached{WS18/19}{02}{2018/10/18}

\pagebreak

\vspace*{-21mm}
\begin{bemerkung}
  Dieses Verfahren gewichtet alle virtuellen Pixel innerhalb eines
  Pixels gleich.
  Meist ist eine \emph{abstandsabhÃ¤ngige Gewichtung} noch besser:

  \begin{center}
    \scalebox{0.5}{\LARGE\input{fig_scanRaumStattFarbe4}}
  \end{center}

  Manchmal werden auch Ã¼berlappende Masken verwendet.
\end{bemerkung}

\pagebreak

\begin{center}
  \begin{tabular}{c@{\qquad\qquad}c}
    \includegraphics[scale=0.6]{fig_scanRaumStattFarbe5} &
    \includegraphics[scale=0.3]{fig_scanRaumStattFarbe6} \\
    & \includegraphics[scale=0.15]{fig_scanRaumStattFarbe7}
  \end{tabular}
\end{center}


\subsection{Farbliche Auf\/lÃ¶sung statt rÃ¤umlicher Auf\/lÃ¶sung}

\begin{description}
\item[Problem:]
  Wie stellt man auf einem Schwarz/WeiÃŸ-Display (\dH jedes Pixel
  kann nur â€anâ€œ oder â€ausâ€œ sein) \emph{Graustufen} dar?

  Wie kann man auf einem â€$k$-Farben-Displayâ€œ (\zB $k = 8$ mit
  den Farben Rot, GrÃ¼n, Blau, Gelb, Zyan, Magenta, WeiÃŸ, Schwarz)
  wesentlich mehr als $k$ \emph{FarbtÃ¶ne} gleichzeitig darstellen?

\item[Idee:]
  Graustufen lassen sich durch \emph{â€Mischenâ€œ} von WeiÃŸ und
  Schwarz, FarbtÃ¶ne durch Mischen der vorhandenen â€Grundfarbenâ€œ
  erzeugen.

  Fasse jeweils \mdef{$nâ‚“ Ã— n_y$} Pixel zu einem
  \emph{virtuellen Pixel} zusammen und belege die
  Pixel jedes virtuellen Pixels â€“ dem MischverhÃ¤ltnis
  entsprechend â€“ mit WeiÃŸ/Schwarz \bzw mit den vorhandenen
  Grundfarben.
\end{description}

\begin{center}
  \includegraphics[scale=0.13]{fig_scanFarbeStattRaum}
\end{center}


\section{Text}


\begin{description}
\item[Problem:]
  Welche Pixel gehÃ¶ren zu einem bestimmten Zeichen eines
  \emph{Zeichensatzes}\index{Zeichensatz}?

\item[â€analytischer Ansatzâ€œ:]
  Zerlege die Zeichen in einfachere Objekte, die gezeichnet werden
  kÃ¶nnen.

  \begin{center}
    \scalebox{0.65}{\LARGE\input{fig_scanText1}}
  \end{center}

  \begin{tabular}{ll}
    â€pâ€œ: & Linie der Breite â€¦ von â€¦ nach â€¦ \cmt{relativ zu $R$} \\
    & Halbkreis der Breite â€¦ mit Radius â€¦  um â€¦ \\
    & \quad â‹®
  \end{tabular}

  Ãœbertragung des Zeichens in die Pixmap durch \emph{Scan Conversion seiner Teilobjekte}.

  \begin{itemize}
  \item[\Bad] relativ langsam

  \item[\Good] sehr flexibel \bzgl des Schriftbilds:
    \begin{description}
    \item[ZeichengrÃ¶ÃŸe:] geeignete Wahl von $u$

    \item[Fettdruck:] Linienbreite geeignet wÃ¤hlen

    \item[SchrÃ¤gschrift:] Wende eine horizontale Scherung
      auf die Beschreibung des Zeichens an.
      \[ \pmat{x \\ y} â‡ \pmat{1 & s \\ 0 & 1} Â· \pmat{x \\ y} \]

      \begin{center}
        \includegraphics[scale=0.65]{fig_scanText2}
      \end{center}
    \end{description}
  \end{itemize}

\item[â€Pre-convertingâ€œ:]
  FÃ¼hre \emph{vorab} fÃ¼r jedes Zeichen die Scan Conversion in eine
  eigene Pixmap durch und \emph{kopiere} spÃ¤ter deren Inhalt in die
  â€Ziel-Pixmapâ€œ.

  \pagebreak

  \vspace*{-22mm}
  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_scanText3}}
  \end{center}

  \pagebreak

  \begin{itemize}
  \item[\Good] sehr schnell

  \item[\Bad] benÃ¶tigt viel Speicherplatz: FÃ¼r jede
    Erscheinungsform eines Zeichens
    \begin{itemize}
    \item ZeichengrÃ¶ÃŸe
    \item normal/fett
    \item normal/schrÃ¤g
    \end{itemize}
    muss eine eigene Pixmap gespeichert werden!
  \end{itemize}
\end{description}

In der Praxis wird oft eine \emph{gemischte Strategie} verwendet:

\begin{itemize}
\item Alle ZeichensÃ¤tze liegen in einer analytischen Beschreibung
  vor;

\item die am hÃ¤ufigsten verwendeten ZeichensÃ¤tze werden zusÃ¤tzlich
  pre-converted,

\item seltener benutzte Zeichen(sÃ¤tze) werden erst bei Bedarf in
  Pixel umgesetzt.
\end{itemize}
