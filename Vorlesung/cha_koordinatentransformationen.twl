\chapter{Koordinatentransformationen}

\begin{center}
  \scalebox{0.525}{\LARGE\input{fig_koordUeberblick}}
\end{center}

\pagebreak

\begin{bemerkung}
  \emph{OpenGL}\index{OpenGL} ist ein weit verbreiteter Grafik-Standard mit
  verschiedenen Möglichkeiten für
  \begin{itemize}
  \item die Beschreibung von Objekten,
  \item Handhabung hierarchischer Szenen,
  \item Festlegung von Projektionen und anderen Transformationen,
  \item Clipping (⇝ Kapitel~\ref{cha:clipping}) und
    Verdeckungsbehandlung (⇝ Kapitel~\ref{cha:sichtbarkeit}),
  \item Färbung (⇝ Kapitel~\ref{cha:faerbung}),
  \item …
  \end{itemize}
  In der Vorlesung werden wir an geeigneten Stellen auf OpenGL
  verweisen.
  \hfill \raisebox{0mm}[1mm][0mm]{\includegraphics[scale=0.25]{logo_OpenGL}}

  Im Februar 2016 wurde Version 1.0 des Nachfolgers
  \emph{Vulkan}\index{Vulkan} veröffentlicht.
  \hfill \raisebox{0mm}[1mm][0mm]{\includegraphics[scale=0.0625]{logo_Vulkan}}
\end{bemerkung}

\pagebreak


\section{Von der Projektionsebene zu
  Gerätekoordinaten}

\begin{description}
\item[Ziel:]
  Bilde den Bereich
  $\ek{\underline{u}; \overline{u}} × \ek{\underline{v}; \overline{v}}$
  „mit möglichst geringer Verzerrung“ in den Pixelbereich \\
  $\ek{\underline{i}, …, \overline{i}} × \ek{\underline{j}, …, \overline{j}}$
  ab.

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_koordNormGeraetAbbildung}}
  \end{center}

  \pagebreak

\item[Annahme:]
  Die Pixel liegen in $i$-Richtung um einen Faktor $\mdef{d}$
  dichter als in $j$-Richtung:

  \begin{center}
    \scalebox{0.5}{\LARGE\input{fig_koordNormGeraetFaktor}}
  \end{center}

  \begin{itemize}
  \item[⇒] $u$-Koordinaten müssen $d$-fach stärker gestreckt werden
  \end{itemize}
\end{description}

\begin{enumerate}
\item
  $v$-Bereich hat die Länge
  $Δ v = \overline{v} - \underline{v}$

  $j$-Bereich hat die Länge
  $Δ j = \overline{j} - \underline{j}$

  $⇒ \quad 0 ≤ \text{Streckfaktor } s ≤ \frac{Δ j}{Δ v}$

\item
  analog:
  $0 ≤ d · s ≤ \frac{Δ i}{Δ u} = \frac{\overline{i} - \underline{i}}{\overline{u} - \underline{u}}$

  $⇔ \quad 0 ≤ s ≤ \frac{Δ i}{d · Δ u}$
\end{enumerate}

\pagebreak

Setze also
\[ s := \min\mk{\frac{\overline{i} - \underline{i}}{d · ( \overline{u} - \underline{u} )},
  \frac{\overline{j} - \underline{j}}{\overline{v} - \underline{v}}} \]
und damit
\begin{align*}
  i &:= d · s · \rk{u - \underline{u}} + \underline{i} \\
  j &:= s · \rk{v - \underline{v}} + \underline{j}
\end{align*}
\bzw
\begin{align*}
  \pmat{i \\ j} &= \underbrace{\pmat{d · s & 0 \\ 0 & s}}_{\textstyle\mdef{=: M_{gp}}}
  · \pmat{u \\ v} +
  \underbrace{\pmat{\underline{i} - d · s · \underline{u} \\
      \underline{j} - s · \underline{v}}}_{\textstyle\mdef{=: t_{gp}}} \\
  &= \underbrace{M_{gp} · \pmat{u \\ v} + t_{gp}}_{\textstyle\mdef{=: A_{gp}}}
  \quad \text{\cmt{affine Transformation}} \,\text.
\end{align*}

\pagebreak

\begin{bemerkung}
  Bei OpenGL wird der verfügbare Pixelbereich ganz genutzt:
  \[ M_{gp} = \pmat{sᵢ & 0 \\ 0 & sⱼ} \,, \quad
  t_{gp} = \pmat{\underline{i} - sᵢ · \underline{u} \\ \underline{j} - sⱼ · \underline{v}} \]
  mit
  \[ sᵢ = \frac{\overline{i} - \underline{i}}{\overline{u} - \underline{u}} \,, \quad
  sⱼ = \frac{\overline{j} - \underline{j}}{\overline{v} - \underline{v}} \]
  Für 
  $\rk{\overline{i} - \underline{i}} : \rk{\overline{j} - \underline{j}} 
  ≠ d · \rk{\overline{u} - \underline{u}} : \rk{\overline{v} - \underline{v}}$
  treten dabei Verzerrungen auf.
\end{bemerkung}

\begin{bemerkung}
  Werden ganzzahlige Koordinaten benötigt, so setzt man
  \[ \pmat{i \\ j} = \round\fk{A_{gp} \pmat{u \\ v}} \,\text. \]
\end{bemerkung}


\section{Projektion}

Eine Projektion ist bestimmt durch:

\begin{description}
\item[Projektionstyp:] \mbox{}

  \begin{center}
    \scalebox{0.55}{\huge\input{fig_koordProjektion1}}
  \end{center}

\item[Projektionsrichtung:] \mbox{}

  \begin{center}
    \includegraphics[scale=0.55]{fig_koordProjektion2}
  \end{center}

  \pagebreak

\item[Koordinatensystem] in der Projektionsebene:

  \begin{center}
    \scalebox{0.55}{\huge\input{fig_koordProjektion4}}
  \end{center}

\item[\textmd{(}Lage der Projektionsebene] zur Projektionsrichtung:)

  \begin{center}
    \includegraphics[scale=0.6]{fig_koordProjektion3}
  \end{center}

\end{description}


\subsection{„Standard-Parallelprojektion“}

\begin{center}
  \scalebox{0.55}{\huge\input{fig_koordStandardParallel}}%πₚ
\end{center}

\begin{description}
\item[Projektionsebene:] Ebene $z ≡ zₚ$ (parallel zur
  $xy$-Ebene) im (rechtshändigen) „normalen“ dreidimensionalen
  Koordinatensystem
\item[Projektionsrichtung:] parallel zur $z$-Achse
\item[Koordinatensystem in der Projektionsebene:] $x$, $y$ aus dem
  dreidimensionalen Koordinatensystem
\end{description}

\textbf{also:}
\begin{align*}
  \pmat{u \\ v} &= \pmat{x \\ y} =
  \underbrace{\pmat{1 & 0 & 0 \\ 0 & 1 & 0}}_{\textstyle\mdef{=: Mₚₛ}}
  · \pmat{x \\ y \\ z} \\[1em]
  π(\point{q}) &= Mₚₛ · \point{q} =: \mdef{Aₚₛ}(\point{q}) \quad
  \text{\cmt{affine [sogar lineare] Transformation}}
\end{align*}


\subsection{„Standard-Perspektivische Projektion“}

\begin{center}
  \scalebox{0.6}{\LARGE\input{fig_koordStandardPerspektiv}}%πₚ
\end{center}

\begin{description}
\item[Projektionsebene:] Ebene $z ≡ zₚ$ im (rechtshändigen)
  „normalen“ dreidimensionalen Koordinatensystem
\item[Projektionsrichtung:] gegeben durch das
  Projektions\emph{zentrum im Ursprung} des $(x, y, z)$-Systems
\item[Koordinatensystem in der Projektionsebene:] $x$, $y$ aus dem
  dreidimensionalen Koordinatensystem
\end{description}

\pagebreak

Wegen $π(\point{q}) = \rk{u, v, zₚ}ᵀ$ liefert der
\emph{Strahlensatz}

\begin{center}
  \scalebox{0.6}{\LARGE\input{fig_koordStrahlensatz}}%πₚ
\end{center}

\[ \frac{v}{y} = \frac{zₚ}{z} = \frac{u}{x} \]
und damit
\[ \pmat{u \\ v} = \frac{zₚ}{z} · \pmat{x \\ y} \,\text. \]

⇒ \emph{keine affine Transformation!}

\pagebreak


\vspace*{-32mm}
\subsection{Allgemeine Parallel- bzw.\ perspektivische Projektion}

\begin{description}
\item[Problem:] Für die Standard-Projektionen müssen die
  Objekte so positioniert werden, dass sie bei einer bestimmten
  Lage der Projektionsebene ($z ≡ zₚ$) sichtbar sind.

  In Analogie zu einer Aufnahme mit einer Kamera sollte es möglich
  sein, die Objekte in einem für die Modellierung „natürlichen“
  Koordinatensystem zu positionieren und die Projektionsebene
  geeignet zu wählen.
\end{description}

Dies kann etwa folgendermaßen realisiert werden (\zB in OpenGL):

\begin{center}
  \scalebox{0.6}{\LARGE\input{fig_koordAllgemein1}}%ₚ
\end{center}

\begin{itemize}
\item Lege (in dem auch zur Positionierung der Objekte verwendeten
  $(x, y, z)$-Koordinatensystem)
  \begin{itemize}
  \item eine \emph{Augenposition}\index{Augenposition} $\point{a}$ und
  \item einen \emph{Zielpunkt}\index{Zielpunkt} $\point{l}$ („look at“)
  \end{itemize}
  sowie den Abstand $- zₚ$ der Projektionsebene fest.

  Dann befindet sich die Projektionsebene im Abstand $- zₚ$ vom
  Augenpunkt und ist senkrecht zur Richtung
  $\vektor{r} = \overrightarrow{\point{a}\point{l}}$.
  \begin{itemize}
  \item[⇒]
    $\widehat{\vektor{n}} := - \frac{\vektor{r}}{\norm[2]{\vektor{r}}}$
    ist ein (zum Augenpunkt zeigender, normierter)
    Normalenvektor zur Projektionsebene.
  \end{itemize}

\item Der Ursprung $\point{o}$ des $(u, v)$-Koordinatensystems
  liegt auf dem Strahl $\overrightarrow{\point{a}\point{l}}$.

  \pagebreak

\item Die positive $v$-Achse ergibt sich aus der Orthogonalprojektion
  einer (in $x$, $y$, $z$ gegebenen) „Aufwärtsrichtung“
  $\mathtxtit{up} ∈ ℝ³$.

  \cmt{$\mathtxtit{up}$ bestimmt, ob die [in Richtung $\point{l}$
    zeigende] Kamera gedreht ist [\zB für eine „Hochformat“-Aufnahme].}

  \begin{align*}
    \vektor{v} &:= \text{Orthogonalprojektion von $\mathtxtit{up}$ auf Projektionsebene} \\
    &= \mathtxtit{up}
    - \text{Komponente von $\mathtxtit{up}$ in Richtung $\widehat{\vektor{n}}$} \\
    &= \mathtxtit{up} - \angk{\mathtxtit{up}, \widehat{\vektor{n}}} · \widehat{\vektor{n}} \\
    &\quad \scalebox{0.5}{\LARGE\input{fig_koordAllgemein2}} \\
    \widehat{\vektor{v}} &= \frac{\vektor{v}}{\norm[2]{\vektor{v}}}
  \end{align*}

  \pagebreak

\item Die $u$-Achse wird so gewählt, dass
  $\rk{\point{o}; \widehat{\vektor{u}}, \widehat{\vektor{v}}, \widehat{\vektor{n}}}$
  \cmt{normierte Vektoren}
  ein \emph{rechtshändiges} 3D-Ko\-or\-di\-na\-ten\-sys\-tem bilden:
  \begin{align*}
    \widehat{\vektor{u}} &= \widehat{\vektor{v}} × \widehat{\vektor{n}} \\
    &= \pmat{\widehat{v}_y \widehat{n}_z - \widehat{v}_z \widehat{n}_y \\
      \widehat{v}_z \widehat{n}ₓ - \widehat{v}ₓ \widehat{n}_{z} \\
      \widehat{v}ₓ \widehat{n}_y - \widehat{v}_y \widehat{n}ₓ}
    = \det \pmat{\widehat{\vektor{x}} & \widehat{\vektor{y}} & \widehat{\vektor{z}} \\
      \widehat{v}ₓ & \widehat{v}_y & \widehat{v}_{z} \\
      \widehat{n}ₓ & \widehat{n}_y & \widehat{n}_{z}}
  \end{align*}
  ($\widehat{\vektor{x}}$, $\widehat{\vektor{y}}$,
  $\widehat{\vektor{z}}$: Einheitsvektoren in $x$-, $y$- \bzw $z$-Richtung)

  \begin{description}
  \item[Bemerkung:]
    Es gilt
    \begin{align*}
      \angk{\widehat{\vektor{u}}, \widehat{\vektor{n}}}
      = \angk{\widehat{\vektor{u}}, \widehat{\vektor{v}}} &= 0 \\
      \norm[2]{\widehat{\vektor{u}}} &= 1 \\
      \det\fk{\widehat{\vektor{u}} | \widehat{\vektor{v}} | \widehat{\vektor{n}}}
      &= \emcol{\text{\boldmath$+$}}1
      \qquad \text{\cmt{rechtshändig}}
    \end{align*}
  \end{description}
\end{itemize}

Für
\begin{itemize}
\item Parallelprojektion entlang der Richtung $±\vektor{r}$ \bzw
\item perspektivische Projektion mit Zentrum $\point{a}$
\end{itemize}
liegt damit bezüglich $(u, v, n)$-Koordinaten „fast die
Standardsituation“ vor.
\cmt{Der Augenpunkt liegt nicht im Ursprung, sondern an Position $\rk{0, 0, - zₚ}$.}

Die Projektion eines Punktes $\point{q} = (x, y, z)ᵀ$ (in
\emph{„Weltkoordinaten“}\index{Weltkoordinaten}) erfolgt also mit der Standard-Projektion,
\emph{nachdem} die folgenden Schritte durchgeführt wurden:

\begin{enumerate}
\item Verschiebung in den Ursprung des
  $\rk{\point{o}; \widehat{\vektor{u}}, \widehat{\vektor{v}}, \widehat{\vektor{n}}}$-Systems:
  \[ \underbrace{\pmat{\widetilde{x} \\ \widetilde{y} \\
        \widetilde{z}}}_{\textstyle\mygreen{\widetilde{\point{q}}}}
    = \underbrace{\pmat{x \\ y \\ z}}_{\textstyle\mygreen{\point{q}}}
    - \underbrace{\pmat{oₓ \\ o_y \\ o_z}}_{\textstyle\mygreen{\point{o}}} \]
  mit $\point{o} = \point{a} + zₚ · \widehat{\vektor{n}}$

\item alte Koordinatenrichtungen, ausgedrückt in den neuen:
  \[ u = \text{Länge der Komponente $\widetilde{\vektor{q}}$ in
      Richtung $\widehat{\vektor{u}}$}
    = \angk{\widehat{\vektor{u}}, \widetilde{\vektor{q}}} \\
    = \widehat{\vektor{u}}ᵀ · \widetilde{\vektor{q}} \]
  analog:
  \[ v = \widehat{\vektor{v}}ᵀ · \widetilde{\vektor{q}} \,\text, \qquad
    n = \widehat{\vektor{n}}ᵀ · \widetilde{\vektor{q}} \,\text, \]
  also
  \[ \pmat{u \\ v \\ n}
    = \pmat{\widehat{\vektor{u}}ᵀ \\\hline\\[-2ex] \widehat{\vektor{v}}ᵀ \\\hline\\[-2ex]
      \widehat{\vektor{n}}ᵀ}
    · \widetilde{\vektor{q}} \\
    = \rk{\widehat{\vektor{u}} | \widehat{\vektor{v}} | \widehat{\vektor{n}}}ᵀ
    · \widetilde{\vektor{q}} \]

  \pagebreak

  \begin{description}
  \item[Bemerkung:]
    Die Matrix
    \[ Mₖ := \rk{\widehat{\vektor{u}} | \widehat{\vektor{v}} | \widehat{\vektor{n}}} \]
    drückt „neue“ Koordinaten in „alten“ aus, vermittelt
    also den Koordinatenwechsel
    \[ (u, v, n) ⇝ \rk{\widetilde{x}, \widetilde{y}, \widetilde{z}} \,\text. \]
    Daher wird der Koordinatenwechsel
    \[ \rk{\widetilde{x}, \widetilde{y}, \widetilde{z}} ⇝ (u, v, n) \]
    durch die Matrix
    \[ Mₖ⁻¹ = Mₖᵀ \]
    ausgedrückt.
  \end{description}

\item Verschiebung des Augenpunktes in den Ursprung:
  \[ \underbrace{\pmat{u' \\ v' \\ n'}}_{\textstyle\mygreen{\point{q}'}}
    = \pmat{u \\ v \\ n} +
    \underbrace{\pmat{0 \\ 0 \\ zₚ}}_{\textstyle\mygreen{\point{d}}} \]
\end{enumerate}

Insgesamt gilt dann:
\begin{align*}
  \point{q}' &= Mₖᵀ · \rk{\point{q} - \point{o}} + \vektor{d} \\
  &= Mₖᵀ · \point{q} + \rk{\vektor{d} - Mₖᵀ · \point{o}} \\
  &=: M_{sw} · \point{q} + \vektor{t}_{sw}
  \qquad \text{\cmt{affine Abbildung}}
\end{align*}

\begin{center}
  \scalebox{0.6}{\Large\input{fig_koordAllgemeinSichtbar}}
\end{center}

Der später im Bild \emph{sichtbare Bereich} wird festgelegt durch ein
\emph{Projektionsfenster}\index{Projektionsfenster}
$\mdef{\ek{\underline{u}, \overline{u}} × \ek{\underline{v}, \overline{v}}}$,
das den Ursprung $\point{o}$ des Koordinatensystems nicht enthalten
muss.


\subsection{Projektive („homogene“) Koordinaten}

\minisec{Motivation}

\begin{itemize}
\item Die Schachtelung affiner Abbildungen
  \[ \point{q} ↦ M_{gp} · \rk{Mₚₛ · \rk{M_{sw} · \point{q} + t_{sw}}} + t_{gp} \]
  benötigt viele Operationen.
  Ohne die Translationen könnten die Matrizen zu einer einzigen
  Matrix
  \[ M := M_{gp} · Mₚₛ · M_{sw} \]
  zusammengefasst werden, und die Transformationen
  \[ \point{q} ↦ M · \point{q} \]
  wären wesentlich effizienter.
  \Reached{WS15/16}{03}{2015/11/05}
  \Reached{WS16/17}{03}{2016/11/03}

  \emph{Kann eine Translation bei geeigneter Koordinatenwahl als
    lineare Transformation (Matrix) geschrieben werden?}

\item Perspektivische Projektion führt nicht einmal auf eine affine
  Transformation.

  \emph{Kann sie bei geeigneter Koordinatenwahl „affin (oder sogar
    linear) gemacht“ werden?}
\end{itemize}

\begin{description}
\item[$\mathbf{n}$-dimensionaler projektiver Raum%
  \index{projektiver Raum}\index{Raum!projektiver}:]
  \[ \mdef{ℙₙ} := \text{Menge aller eindimensionalen Unterräume des $ℝⁿ⁺¹$} \]

\item[Elemente des \boldmath$ℙₙ$:]
  Ergänze die $n$-dimensionalen Koordinaten durch eine
  $(n + 1)$-te mit Wert $1$:
  \[ \rk{x₁, …, xₙ} ⇝ \rk{x₁, …, xₙ, 1} \]

  Identifiziere im $ℝⁿ⁺¹$ alle Vielfachen ($≠ 0$) eines
  Vektors:
  \[ \rk{x₁, …, xₙ, xₙ₊₁} ≡ \rk{τ x₁, …, τ xₙ, τ xₙ₊₁} \quad \text{für $τ ≠ 0$} \]

\item[Beispiel:] \mbox{}

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_koordProjektiv}}%ℝ
  \end{center}
\end{description}

\begin{itemize}
\item Für $xₙ₊₁ ≠ 0$ entspricht
  $\rk{x₁, …, xₙ, xₙ₊₁}$ dem (eindeutigen) Punkt
  $\rk{\frac{x₁}{xₙ₊₁}, …, \frac{xₙ}{xₙ₊₁}}$
  im $ℝⁿ$,
\item Für $xₙ₊₁ = 0$ entspricht
  $\rk{x₁, …, xₙ, 0}$ \emph{keinem} Punkt im
  $ℝⁿ$
  \emph{(„unendlich ferner Punkt“)}\index{unendlich ferner Punkt}%
  \index{Punkt!unendlich ferner}.
\end{itemize}

\minisec{Wie übertragen sich $\mathbf{n}$-dimensionale Transformationen auf
  projektive Koordinaten?}

\begin{description}
\item[lineare Transformationen:]
  \[ \point{x} ↦ \point{y} := M · \point{x} \,, \qquad \point{x} ∈ ℝⁿ \]

  \begin{Hide}
    \[ \point{ξ} = \pmat{τ \point{x} \\ τ} ↦ \point{η} = \pmat{τ \point{y} \\ τ}
      = \pmat{τ · M \point{x} \\ τ} = \pmat{M · τ \point{x} \\ τ}
      = \underbrace{\rk{\begin{array}{c|c}M & 0 \\\hline 0 &
            1\end{array}}}_{\textstyle\mymagenta{=: M'}}
      · \underbrace{\pmat{τ \point{x} \\ τ}}_{\textstyle\mymagenta{= \point{ξ}}} \]
    
    \begin{description}
    \item[\emph{Fazit:}] Lineare Abbildungen sind auch projektiv linear.
    \end{description}
  \end{Hide}

\item[affine Abbildungen:]
  \[ \point{x} ↦ \point{y} := M · \point{x} + \point{t} \,, \qquad \point{x} ∈ ℝⁿ \]

  \begin{Hide}
    \[ \point{ξ} = \pmat{τ \point{x} \\ τ} ↦ \point{η} = \pmat{τ \point{y} \\ τ}
      = \pmat{τ · (M \point{x} + \point{t}) \\ τ}
      = \underbrace{\rk{\begin{array}{c|c}M & \point{t} \\\hline 0 &
            1\end{array}}}_{\textstyle\mymagenta{=: M'}}
      · \underbrace{\pmat{τ \point{x} \\ τ}}_{\textstyle\mymagenta{\point{ξ}}} \]
    
    \begin{description}
    \item[\emph{Fazit:}] \emph{Affine Abbildungen werden projektiv 
        linear!}
    \end{description}
  \end{Hide}

  \pagebreak

  \vspace*{-17mm}
\item[Standard-Parallelprojektion:]
  \[ \pmat{u \\ v} = \pmat{1 & 0 & 0 \\ 0 & 1 & 0} · \pmat{x \\ y \\ z} \]

  \begin{Hide}
    \[ ⇒ \quad
      \pmat{τ u \\ τ v \\ τ} =
      \rk{\begin{array}{ccc|c}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\\hline 0 & 0 & 0 & 1\end{array}}
      · \pmat{τ x \\ τ y \\ τ z \\ τ} \]

    \begin{description}
    \item[\emph{Fazit:}] Die Standard-Parallelprojektion ist
      projektiv linear (klar, da ohnehin linear).
    \end{description}
  \end{Hide}

\item[Standard-Perspektivische Projektion:]

  \[ \pmat{u \\ v} = \frac{zₚ}{z} · \pmat{x \\ y} \]

  \begin{Hide}
    \[ ⇒ \quad
      \pmat{z · u \\ z · v} = \pmat{zₚ · x \\ zₚ · y} \]

    \[ ⇒ \quad
      \pmat{zₚ & 0 & 0 & 0 \\ 0 & zₚ & 0 & 0 \\ 0 & 0 & 1 & 0}
      · \pmat{τ x \\ τ y \\ τ z \\ τ}
      = \pmat{τ z · u \\ τ z · v \\ τ z}
      =: \pmat{τ' · u \\ τ' · v \\ τ'} \]
  \end{Hide}

  \pagebreak

  \begin{Hide}
    \begin{description}
    \item[\emph{Fazit:}] \emph{Auch die Standard-Perspektivische
        Projektion wird projektiv linear!}
    \end{description}
  \end{Hide}
\end{description}
\Reached{WS14/15}{04}{2014/10/30}
\Reached{WS17/18}{03}{2017/10/26}
\Reached{WS19/20}{03}{2019/10/24}

\begin{bemerkungen} \mbox{}
  \begin{enumerate}
  \item In OpenGL können die
    $4 × 4$-„view matrix“ (im Wesentlichen $M_{sw}'$)
    und die Projektion ($≙ Mₚₛ'$)
    auf verschiedene Arten aufgebaut werden:
    \begin{itemize}
    \item automatisch, \zB durch Angabe von
      $\point{a}$, $\point{l}$, $\mathtxtit{up}$ \bzw $- zₚ$, $\underline{u}$, $\overline{u}$,
      $\underline{v}$ und $\overline{v}$,
    \item durch Zusammensetzen einfacherer
      Transformationsmatrizen oder
    \item „von Hand“ durch Angabe der Matrixeinträge
    \end{itemize}
    Die beiden letzten Möglichkeiten erlauben auch
    nicht-orthogonale („oblique“) Parallelprojektionen.

  \item In der „modelview matrix“ wird die „view matrix“
    mit den Modellierungstransformationen
    (Abschnitt~\ref{sec:transformationenInDerModellierung})
    zusammengefasst.

  \item Die „viewport transformation“ vermittelt den
    Übergang von der Projektionsebene zu Gerätekoordinaten.

  \item Auch die $n$-Koordinate (Information über räumliche
    Tiefe) wird durch die eigentliche Projektion geführt
    ($4 × 4$-Matrix statt $3 × 4$).

    (mehr dazu in Kapitel~\ref{cha:clipping} und \ref{cha:sichtbarkeit})
  \end{enumerate}
  \ReachedZoom{WS20/21}{03}{2020/11/12}
\end{bemerkungen}


\section{Transformationen in der Modellierung}
\label{sec:transformationenInDerModellierung}

\emph{hierarchische Modellierung}\index{hierarchische Modellierung}%
\index{Modellierung!hierarchische} eines Tretrollers (stark vereinfacht):
\Reached{WS21/22}{03}{2021/10/28}

Der \emph{Tretroller} besteht aus
\begin{itemize}
\item einer (um eine vertikale Achse drehbaren) „Lenkergruppe“,
\item fünf starren (mit Quadern modellierten) Bauteilen und
\item dem (um eine horizontale Achse drehbaren) Hinterrad.
\end{itemize}

\begin{center}
  \includegraphics[scale=0.5]{fig_koordRollerRoller}
\end{center}

\pagebreak

Die \emph{Lenkergruppe} besteht aus
\begin{itemize}
\item dem (um eine horizontale Achse drehbaren) Rad und
\item fünf starren (mit Quadern modellierten) Bauteilen für Gabel,
  Lenkerstange, \usw
\end{itemize}

\begin{center}
  \includegraphics[scale=0.5]{fig_koordRollerLenker}
\end{center}

\pagebreak

Das \emph{Rad} besteht aus einer vorgegebenen Anzahl von
(jeweils um einen geeigneten Winkel gedrehten) \\
„Speiche/Reifen-Einheiten“.

\begin{center}
  \includegraphics[scale=0.75]{fig_koordRollerRad}
\end{center}

Eine \emph{Speiche/Reifen-Einheit} besteht aus
\begin{itemize}
\item einer Speiche und
\item einem Stück des Reifens
\end{itemize}
(beide modelliert durch Quader).

\pagebreak

Ein \emph{Quader} kann durch geeignete Streckung aus einem
\emph{Einheitswürfel} $\ek{-0,5; 0,5}³$ erzeugt werden.

\begin{center}
  \scalebox{0.45}{\huge\input{fig_koordRollerSpeiche}}
\end{center}

Bei der Projektion auf 2D müssen die folgenden Transformationen auf die
Ecken $\point{P} ∈ ℝ³$ von Einheitswürfeln angewandt werden \\
(ausgehend von projektiven Koordinaten
$\point{P}' = \pmat{τ \point{P} \\ τ}$
erhält man auch projektive 2D-Koordinaten
$\point{u}' = \pmat{τ' u \\ τ' v \\ τ'}$):

\begin{itemize}
\item wenn der Einheitswürfel dargestellt werden soll:
  \[ \point{u}' = M_{\mathrm{proj}}'
    · \underbrace{\point{P}'}_{\text{Ecke des Würfels}} \]
  mit
  \begin{itemize}
  \item $M_{\mathrm{proj}}'$: Projektionsmatrix 3D → 2D
  \end{itemize}

\item wenn der Würfel in ein Element der Speiche/Reifen-Einheit
  (\xfigBlue{Speiche} oder \xfigBlue{Stück des Reifens}) transformiert
  wird:
  \begin{align*}
    \point{u}' &= M_{\mathrm{proj}}'
    · \xfigBlue{\underbrace{M_{\mathrm{tr\_sr}_{\mathrm{s}}}'
        · M_{\mathrm{sc\_sr}_{\mathrm{s}}}'}_{\text{Transformation zur Speiche}}}
    · \underbrace{\point{P}'}_{\text{Würfel}} \qquad \text{\bzw} \\
    \point{u}' &= M_{\mathrm{proj}}'
    · \xfigBlue{\underbrace{M_{\mathrm{tr\_sr}_{\mathrm{r}}}'
        · M_{\mathrm{sc\_sr}_{\mathrm{r}}}'}_{\text{Transformation zum Reifenstück}}}
    · \underbrace{\point{P}'}_{\text{Würfel}}
  \end{align*}
  mit
  \begin{itemize}
  \item $\xfigBlue{M_{\mathrm{sc\_sr}_{\mathrm{s}}}'}$ \bzw
    $\xfigBlue{M_{\mathrm{sc\_sr}_{\mathrm{r}}}'}$:
    (Diagonal-)Streckungsmatrix („scale“) für die
    Speiche \bzw das Reifenstück
  \item $\xfigBlue{M_{\mathrm{tr\_sr}_{\mathrm{s}}}'}$ \bzw
    $\xfigBlue{M_{\mathrm{tr\_sr}_{\mathrm{r}}}'}$:
    anschließende Verschiebung („translate“)
  \end{itemize}

  \pagebreak

\item wenn die Speiche/Reifen-Einheit anschließend in ein
  \xfigGreenIII{Rad} eingebaut wird:
  \[ \point{u}' = M_{\mathrm{proj}}'
    · \xfigGreenIII{\underbrace{M_{\mathrm{rot\_rad}}'}_{\text{Einbau in Rad}}}
    · \underbrace{\xfigBlue{M_{\mathrm{tr\_sr}}' · M_{\mathrm{sc\_sr}}'}
      · \point{P}'}_{\xfigBlue{\text{Speiche/Reifen-Einheit}}} \]
  mit
  \begin{itemize}
  \item $\xfigGreenIII{M_{\mathrm{rot\_rad}}'}$: Rotationsmatrix
    („rotate“) um die (Naben-) Achse
  \end{itemize}

\item wenn das Rad hinten in den \xfigRed{Tretroller} eingebaut wird:
  \[ \point{u}' = M_{\mathrm{proj}}'
    · \xfigRed{\underbrace{M_{\mathrm{tr\_hr}}'
        · M_{\mathrm{rot\_hr}}'}_{\text{Einbau in Roller}}}
    · \underbrace{\xfigGreenIII{M_{\mathrm{rot\_rad}}'} · \xfigBlue{M_{\mathrm{tr\_sr}}'
        · M_{\mathrm{sc\_sr}}'} · \point{P}'}_{\xfigGreenIII{\text{Rad}}} \]
  mit
  \begin{itemize}
  \item $\xfigRed{M_{\mathrm{rot\_hr}}'}$: Drehung des
    Hinterrades
  \item $\xfigRed{M_{\mathrm{tr\_hr}}'}$: anschließende
    Verschiebung an die Position im Roller
  \end{itemize}

  \pagebreak

\item wenn das „Trittbrett“ in den \xfigRed{Tretroller} eingebaut
  wird:
  \[ \point{u}' = M_{\mathrm{proj}}'
    · \xfigRed{\underbrace{M_{\mathrm{tr\_brett}}'
        · M_{\mathrm{sc\_brett}}'}_{\text{Einbau als Trittbrett}}}
    · \underbrace{\point{P}'}_{\text{Würfel}} \]
  mit
  \begin{itemize}
  \item $\xfigRed{M_{\mathrm{sc\_brett}}'}$: Streckungsmatrix für
    das Trittbrett
  \item $\xfigRed{M_{\mathrm{tr\_brett}}'}$: anschließende
    Verschiebung an die Position im Roller
  \end{itemize}
\end{itemize}

\begin{description}
\item[generelles Vorgehen:]
  ist eine „Struktur“ (\zB Tretroller) aus
  „Unterstrukturen“ (\zB Lenkergruppe, Quader für Trittbrett
  \usw, Hinterrad) aufgebaut, dann
  \begin{itemize}
  \item vor dem „Aufruf“ jeder Unterstruktur die 
    zum Einbau erforderlichen Transformationen setzen,
  \item die Unterstruktur aufrufen (und dabei \ggf rekursiv
    genauso verfahren),
  \item anschließend die „Einbau“transformationen
    wieder zurücksetzen
  \end{itemize}

  ⇒ Verwaltung der Transformationsmatrizen mittels \emph{Stack}
\end{description}

\pagebreak

\begin{bemerkung}
  Damit am Ende jede Ecke der Szene mit einer einzigen
  Matrix-Vektor-Multiplikation transformiert werden kann, werden
  bei \emph{OpenGL}\index{OpenGL} stets alle „bislang bekannten“ Matrizen
  aufmultipliziert.

  Beispielsweise liegt vor dem Einbau einer Speiche/Reifen-Einheit
  in das Hinterrad die Matrix
  \[ M' := M_{\mathrm{proj}}' · \xfigRed{M_{\mathrm{tr\_hr}}' · M_{\mathrm{rot\_hr}}'}
    · \xfigGreenIII{M_{\mathrm{rot\_rad}}'} \]
  vor, innerhalb der Speiche/Reifen-Einheit wird sie durch
  \[ M' · \xfigBlue{M_{\mathrm{tr\_sr}_{\mathrm{s}}}' · M_{\mathrm{sc\_sr}_{\mathrm{s}}}'} \]
  ersetzt.
  
  Die auf eine Unterstruktur anzuwendenden Transformationen
  sind daher \emph{in umgekehrter Reihenfolge} anzugeben.
\end{bemerkung}

\pagebreak

\C@OPENGLList{Tretroller/roller.c}{teil1}

\C@OPENGLList{Tretroller/roller.c}{teil2}

\C@OPENGLList{Tretroller/roller.c}{teil3}
\Reached{WS18/19}{03}{2018/10/25}
