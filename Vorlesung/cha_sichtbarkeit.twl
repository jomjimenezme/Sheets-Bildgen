\chapter{Sichtbarkeit}
\label{cha:sichtbarkeit}

\pagebreak

\begin{description}
\item[bisher:] \emph{â€Drahtmodellâ€œ}-Darstellung\index{Drahtmodell-Darstellung}
  \emph{(wire frame)}\index{wire frame} aller Kanten aller Objekte

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtWireframe}
  \end{center}

\item[Ziel:]
  Elimination aller Strecken- und FlÃ¤chenteile, die durch
  â€weiter vorne liegendeâ€œ FlÃ¤chen \emph{verdeckt} werden
  \emph{(hidden line\index{hidden line removal}\,/\,hidden surface removal%
    \index{hidden surface removal})}

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtRemoved}
  \end{center}
\end{description}

â‡’ wesentlich \emph{plastischere Darstellung}


\section{Der Pixel-orientierte Ansatz}

\begin{center}
  \scalebox{0.6}{\LARGE\input{fig_sichtPixel}}
\end{center}

\begin{description}
\item[Beobachtung:]
  Pixel $(u, v)$ erhÃ¤lt die Farbe des Objekts, das
  \begin{itemize}
  \item den durch das Pixel gehenden Projektionsstrahl schneidet
  \end{itemize}
  und
  \begin{itemize}
  \item unter allen Objekten den am nÃ¤chsten bei
    der Projektionsebene liegenden Schnittpunkt liefert.
  \end{itemize}

\item[Folgerung:]
  Gesucht ist der \emph{$\mathbf{n}$-maximale} Schnittpunkt des
  Projektionsstrahls mit einem Objekt.
\end{description}


\subsection{Naive Implementierung}

\begin{description}
\item[Ansatz:]
  Bestimme fÃ¼r jedes Pixel der Pixmap, welche Objekte der
  zugehÃ¶rige Projektionsstrahl schneidet, und leite aus dem
  nÃ¤chstgelegenen Schnittpunkt die Farbe des Pixels ab.
\end{description}

\begin{algorithmus}%
  \label{alg:visibleSurfaceRayTracing}
  \mbox{}\index{visible surface ray tracing}%
  \begin{AlgListInline}
    Algorithmus visible surface ray tracing

    fÃ¼r alle Pixel $P$ der Pixmap
    Â°Â°Â°stelle den Projektionsstrahl durch das Pixel in der Form $\point{q} = \point{q}â‚ + Î» Â· \rk{\point{q}â‚‚ - \point{q}â‚}$ dar,
    Â°Â°Â°Â°Â°Â°Â°Â°so dass Punkte mit grÃ¶ÃŸerem $Î»$ Âºâ€weiter vorneâ€œÂº liegen
    Â°Â°Â°$O^*$ := Âºâ€Hintergrundâ€œÂºÂ°Â°Â°Â°Â°// bislang nÃ¤chstgelegenes Objekt
    Â°Â°Â°$Î»^*$ := $-âˆ$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// Parameterwert des zugehÃ¶rigen Schnittpunkts
    Â°Â°Â°fÃ¼r alle Objekte $Oáµ¢$
    Â°Â°Â°Â°Â°Â°Â§Schnitttest:Â§ PrÃ¼fe, ob der Projektionsstrahl das Objekt $Oáµ¢$ trifft, und bestimme ggf.
    Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°den Parameterwert $Î»áµ¢$ des Schnittpunkts
    Â°Â°Â°Â°Â°Â°wenn Schnittpunkt vorhanden und $Î»áµ¢ > Î»^*$
    Â°Â°Â°Â°Â°Â°Â°Â°Â°$O^*$ := $Oáµ¢$
    Â°Â°Â°Â°Â°Â°Â°Â°Â°$Î»^*$ := $Î»áµ¢$
    Â°Â°Â°setze Pixel $P$ auf die Farbe von Objekt $O^*$
  \end{AlgListInline}
\end{algorithmus}

\pagebreak

\vspace*{-19mm}
\begin{description}
\item[Aufwand:]
  problemrelevante GrÃ¶ÃŸen

  \begin{tabular}{Ll}
    \mdef{p} & Anzahl der Pixel in der Pixmap \\
    \mdef{o} & Anzahl der Objekte \\
    \mdef{ğ’ª(s)} & Aufwand fÃ¼r einen Schnitttest \\
    \mdef{ğ’ª(z)} & Aufwand zum Zeichnen eines Pixels
  \end{tabular}
  
  \bigskip

  \begin{tabular}{ll}
    fÃ¼r alle Pixel & $p$-mal \\
    \qquad Projektionsstrahl darstellen & \qquad $ğ’ª(1)$ \\
    \qquad $O^*$, $Î»^*$ initialisieren & \qquad $ğ’ª(1)$ \\
    \qquad fÃ¼r alle Objekte & \qquad $o$-mal \\
    \qquad\qquad Schnitttest & \qquad\qquad $ğ’ª(s)$ \\
    \qquad\qquad $O^*$, $Î»^*$ aktualisieren & \qquad\qquad $ğ’ª(1)$ \\
    \qquad Pixel zeichnen & \qquad $ğ’ª(z)$ \\ \hline
    $âˆ‘$ & \myred{$ğ’ª(p Â· o Â· s + p Â· z)$}
  \end{tabular}
\end{description}

\begin{bemerkungen} \mbox{}
  \begin{enumerate}
  \item Zeichnen eines Pixels ist \iA in $ğ’ª(z) = ğ’ª(1)$
    mÃ¶glich.
  \item Der Aufwand $ğ’ª(s)$ hÃ¤ngt davon ab, welche Objekte
    zugelassen werden und ob \emph{Vorverarbeitung der Objekte}
    erfolgt.
  \end{enumerate}
\end{bemerkungen}

\pagebreak

\begin{beispiel}
  Die darzustellenden Objekte sind
  \emph{konvexe Polygone mit hÃ¶chstens $\mathbf{m}$ Ecken}.

  Jedes Polygon werde durch seine $\mdef{m'} â‰¤ m$ Ecken und
  einen â€VorwÃ¤rtsâ€œ-Normalenvektor $\vektor{v}$ zur Polygonebene
  gegeben.

  \begin{center}
    \scalebox{0.5}{\huge\input{fig_sichtKonvex1}}%â‚â‚‚â‚ƒâ‚„â‚…
  \end{center}

  Die Ecken seien \emph{entgegen dem Uhrzeigersinn} nummeriert, wenn
  die Polygonebene â€von vorneâ€œ (\dH in Richtung $-\vektor{v}$)
  betrachtet wird.

  \pagebreak

  \begin{enumerate}
  \item \textbf{Schnitttest ohne Vorverarbeitung:}

    \begin{itemize}
    \item Bestimme den Schnittpunkt $\point{S}$ des Strahls mit der
      Polygonebene.

    \item $\point{S}$ liegt genau dann im (konvexen!) Polygon, wenn
      $\point{S}$ \emph{links jeder gerichteten Seite}
      $\overrightarrow{\point{V}â±¼â‚‹â‚\point{V}â±¼}$ liegt
      ($j = 1, â€¦, m'$, mit $\point{V}â‚€ := \point{V}_{m'}$).
    \end{itemize}

    Wie prÃ¼ft man, ob $\point{S}$ links oder rechts von
    $\overrightarrow{\point{V}â±¼â‚‹â‚\point{V}â±¼}$ liegt?

    \begin{center}
      \scalebox{0.5}{\huge\input{fig_sichtKonvex2}}%â±¼â‚‹â‚
    \end{center}

    $\mdef{\vektor{l}} := \vektor{v} Ã— \rk{\point{V}â±¼ - \point{V}â±¼â‚‹â‚}$
    ist ein â€nach linksâ€œ zeigender Vektor.

    \begin{itemize}
    \item[â‡’] $\point{S}$ liegt genau dann links von
      $\overrightarrow{\point{V}â±¼â‚‹â‚\point{V}â±¼}$, wenn
      \[ \vektor{l}áµ€ Â· \rk{\point{S} - \point{V}â±¼â‚‹â‚} > 0 \,\text. \]
    \end{itemize}

    \begin{AlgListInline}
      Algorithmus Schnitttest ohne Vorverarbeitung

      innen := true
      fÃ¼r $j = 1, â€¦, m'$
      Â°Â°Â°innen := innen and $\rk{\vektor{v} Ã— \rk{\point{V}â±¼ - \point{V}â±¼â‚‹â‚}}áµ€ Â· \rk{\point{S} - \point{V}â±¼â‚‹â‚} > 0$
    \end{AlgListInline}

    \begin{description}
    \item[Aufwand:] $\myred{ğ’ª(s)} = ğ’ª\fk{m'} = \myred{ğ’ª(m)}$
    \end{description}
    
  \item \textbf{Schnitttest mit Vorverarbeitung:}
    
    \begin{itemize}
    \item Ein konvexes Polygon zerfÃ¤llt in zwei (\evtl leere)
      horizontale und zwei \bzgl der $v$-Achse
      \emph{streng monotone PolygonzÃ¼ge}\index{streng monotoner Polygonzug}%
      \index{Polygonzug!streng monotoner} $L$ \bzw $R$:

      \begin{center}
        \scalebox{0.5}{\huge\input{fig_sichtKonvex3}}
      \end{center}

    \item $\point{S}$ liegt genau dann im Polygon, wenn
      \begin{itemize}
      \item $v_{\textrm{min}} < \point{S}áµ¥ < v_{\textrm{max}}$ und
      \item $\point{S}$ links der beiden monotonen PolygonzÃ¼ge
        liegt.
      \end{itemize}

    \item Ein monotoner Polygonzug mit $k$ Ecken zerlegt die Ebene in $2k$ Gebiete:

      \begin{center}
        \scalebox{0.4}{\Huge\input{fig_sichtKonvex4}}
      \end{center}

      Durch \emph{binÃ¤re Suche} kann mit $ğ’ª(\log k)$ Vergleichen
      der horizontale Streifen bestimmt werden, in dem $\point{S}$
      liegt.
      Danach genÃ¼gt \emph{1 â€Links/Rechts-Testâ€œ} um zu
      entscheiden, ob $\point{S}$ links oder rechts des monotonen
      Polygonzugs liegt.
    \end{itemize}

    \begin{AlgListInline}
      Algorithmus Vorverarbeitung

      fÃ¼r alle konvexen Polygone $Oáµ¢$
      Â°Â°Â°fÃ¼hre ein geeignetes $(u, v, w)$-Koordinatensystem ein, so dass $w â‰¡ 0$ die Polygonebene ist
      Â°Â°Â°rechne die Ecken $\point{V}áµ¢$ in $(u, v, w)$-Koordinaten um
      Â°Â°Â°bestimme minimale und maximale $v$-Koordinaten $v_{\textmd{\textrm{min}}}$ bzw. $v_{\textmd{\textrm{max}}}$
      Â°Â°Â°speichere die beiden monotonen PolygonzÃ¼ge in Datenstrukturen, die ÂºfÃ¼rÂº binÃ¤re Suche
      Â°Â°Â°Â°Â°Â°Â°Â°geeignet sind (z.@\,@B. Felder)
    \end{AlgListInline}

    \begin{description}
    \item[Aufwand:] \mbox{}

      \begin{tabular}{ll}
        fÃ¼r alle Polygone & $o$-mal \\
        \qquad $(u, v, w)$-System berechnen & \qquad $ğ’ª(1)$ \\
        \qquad $\point{V}áµ¢$ umrechnen & \qquad $ğ’ª(m)$ \\
        \qquad $v_{\textrm{min}}$, $v_{\textrm{max}}$ bestimmen & \qquad $ğ’ª(m)$ \\
        \qquad PolygonzÃ¼ge extrahieren & \qquad $ğ’ª(m)$ \\ \hline
        $âˆ‘$ & \myred{$ğ’ª(o Â· m)$}
      \end{tabular}
    \end{description}

    \begin{AlgListInline}
      Algorithmus Schnitttest

      berechne den Schnittpunkt $\point{S} = \rk{Sâ‚“, S_y, S_z}$ des Projektionsstrahls mit der Polygonebene
      rechne $\point{S}$ in $(u, v, w)$-Koordinaten um
      wenn $v_{\textmd{\textrm{min}}} < Sáµ¥ < v_{\textmd{\textrm{max}}}$
      Â°Â°Â°// teste â€$\point{S}$ links von $R$?â€œ
      Â°Â°Â°bestimme mit binÃ¤rer Suche denjenigen durch $R$ definierten Streifen $\ek{vâ±¼â‚‹â‚; vâ±¼}$,
      Â°Â°Â°Â°Â°Â°Â°Â°der $\point{S}$ enthÃ¤lt
      Â°Â°Â°innen := $\pmat{vâ±¼â‚‹â‚ - vâ±¼ \\ uâ±¼ - uâ±¼â‚‹â‚}áµ€ Â· \pmat{Sáµ¤ - uâ±¼â‚‹â‚ \\ Sáµ¥ - vâ±¼â‚‹â‚} > 0$
      Â°Â°Â°@\raisebox{-170pt}[0bp][100pt]{\scalebox{0.5}{\input{fig_sichtKonvex5}}}@
      Â°Â°Â°wenn innen
      Â°Â°Â°Â°Â°Â°teste Âºâ€Âº$\point{S}$ links von $L$?Âºâ€œÂºÂ°Â°Â°Â°Â°// analog
    \end{AlgListInline}%â±¼â‚‹â‚

    \pagebreak

    \begin{description}
    \item[Aufwand:] \mbox{}

      \begin{tabular}{ll}
        $\point{S}$ berechnen & $ğ’ª(1)$ \\
        $\point{S}$ in $(u, v, w)$ umrechnen & $ğ’ª(1)$ \\
	fÃ¼r $R$ und $L$ & $2$-mal \\
        \qquad binÃ¤re Suche & \qquad $ğ’ª(\log m)$ \\
        \qquad innen testen & \qquad $ğ’ª(1)$ \\ \hline
        $âˆ‘$ & \myred{$ğ’ª(\log m)$}
      \end{tabular}
    \end{description}
  \end{enumerate}

  \begin{description}
  \item[Fazit:] Der Gesamtaufwand betrÃ¤gt
    \begin{center}
      \begin{tabular}{Ll}
        ğ’ª(p Â· o Â· \myred{m} + p Â· z) & ohne Vorverarbeitung \\
        \multicolumn{2}{l}{und} \\
        ğ’ª(\myred{o Â· m} + p Â· o Â· \myred{\log m} + p Â· z) & mit Vorverarbeitung.
      \end{tabular}
    \end{center}
  \end{description}
\end{beispiel}

\pagebreak

\vspace*{-21mm}
\begin{bemerkung}
  Typische GrÃ¶ÃŸenordnungen:
  \begin{align*}
    p &= 1920 Ã— 1080 â‰ˆ 2 Â· 10â¶ \\
    o &â‰« 1000
  \end{align*}
  â‡’ \emph{â‰« 10â¹ Schnitttests} notwendig!
  \Reached{WS15/16}{05}{2015/11/19}

  Visible surface ray tracing ist
  \begin{itemize}
  \item[\Bad] sehr aufwÃ¤ndig

  \item[\Good] relativ leicht zu sehr anspruchsvollen
    Bilderzeugungsverfahren erweiterbar.

    â‡ rekursives Raytracing
    (Abschnitt~\ref{sec:faerbungRayTracing})
  \end{itemize}
  \Reached{WS16/17}{05}{2016/11/17}
\end{bemerkung}


\subsection{Optimierung~I: Zell-Raster-Technik}
\label{subsec:sichtbarkeitZellRaster}
\index{Zell-Raster-Technik}

\begin{description}
\item[Idee:] In Algorithmus~\ref{alg:visibleSurfaceRayTracing} wird
  jeder Projektionsstrahl mit jedem Objekt geschnitten.

  Die Objekte sind aber meist verhÃ¤ltnismÃ¤ÃŸig klein, Ã¼berdecken
  also nur einen Teil des Bildschirms.

  \begin{itemize}
  \item[â‡’] Versuche, in einer \emph{Vorbereitungsphase}
    Information darÃ¼ber zu sammeln, welche Objekte
    Ã¼berhaupt mit welchen Projektionsstrahlen geschnitten
    werden mÃ¼ssen.
  \end{itemize}
\end{description}

\pagebreak

\vspace*{-20mm}
Es ist aufwÃ¤ndig (Rechenzeit, Speicherplatz), fÃ¼r jeden einzelnen
Strahl die geschnittenen Objekte zu bestimmen.

\begin{itemize}
\item[â‡’] nur \emph{summarische Analyse}:

  \begin{itemize}
  \item Unterteile die Pixmap in $\mdef{r = râ‚ Ã— râ‚‚}$
    \emph{â€Zellenâ€œ}\index{Zelle}.

  \item Bestimme fÃ¼r jede Zelle alle Objekte, welche (zumindest
    teilweise) in die Zelle fallen.

    \scalebox{0.5}{\huge\input{fig_sichtZellenBsp}}%â‚â‚‚â‚ƒâ‚„
    \quad
    \raisebox{4em}{%
      \begin{tabular}{ll}
        $Zâ‚â‚$: & \xfigBlue{$Oâ‚$}, \xfigRed{$Oâ‚‚$}, \xfigGreenIII{$Oâ‚ƒ$} \\
        $Zâ‚â‚‚$: & \xfigBlue{$Oâ‚$}, \xfigRed{$Oâ‚‚$} \\
        $Zâ‚â‚ƒ$: & \xfigBlue{$Oâ‚$} \\
        $Zâ‚‚â‚$: & \xfigRed{$Oâ‚‚$}, \xfigGreenIII{$Oâ‚ƒ$} \\
        $Zâ‚‚â‚‚$: & \xfigBlue{$Oâ‚$}, \xfigRed{$Oâ‚‚$}, \xfigGreenIII{$Oâ‚ƒ$} \\
        $Zâ‚‚â‚ƒ$: & \xfigBlue{$Oâ‚$} \\
        $Zâ‚ƒâ‚$: & \xfigGreenIII{$Oâ‚ƒ$} \\
        $Zâ‚ƒâ‚‚$: & \xfigGreenIII{$Oâ‚ƒ$}, \xfigMagentaIII{$Oâ‚„$} \\
        $Zâ‚ƒâ‚ƒ$: & \xfigBlue{$Oâ‚$}, \xfigMagentaIII{$Oâ‚„$}
      \end{tabular}}

  \item Jeder Projektionsstrahl geht durch eine Zelle.
    FÃ¼hre nur Schnitttests mit den Objekten durch, welche die
    Zelle treffen.

    (Im obigen Beispiel geht der Strahl durch $Zâ‚‚â‚$, also nur
    Schnitttests mit $Oâ‚‚$ und $Oâ‚ƒ$.)
  \end{itemize}
\end{itemize}

\begin{description}
\item[Frage:] Wie bestimmt man diese Objekte mÃ¶glichst effizient?

\item[Antwort:] Man geht von den Objekten aus und bestimmt zu
  jedem Objekt die von ihm berÃ¼hrten Zellen!
\end{description}

\pagebreak

\minisec{Methode~I: â€Scan Conversionâ€œ}

Das Zellraster kann als grÃ¶bere Pixmap mit $râ‚ Ã— râ‚‚$
Pixeln interpretiert werden.

\begin{itemize}
\item[â‡’] Die zu einem Objekt gehÃ¶renden Zellen kÃ¶nnen
  durch Scan Conversion in das Zellraster ermittelt werden.

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtZellenScan}
  \end{center}
\end{itemize}

\begin{itemize}
\item[\Good] liefert bestmÃ¶gliche Aussage, \dH genau die
  berÃ¼hrten Zellen

\item[\Bad] verhÃ¤ltnismÃ¤ÃŸig aufwÃ¤ndig
\end{itemize}

\pagebreak

\minisec{Methode~II: â€Bounding Boxâ€œ}

\begin{itemize}
\item Projiziere alle Ecken des Objekts in das Zellraster.

\item Bestimme das kleinstmÃ¶gliche achsenparallele Rechteck im
  Zellraster, das alle diese Ecken enthÃ¤lt \\
  \emph{(â€Bounding Boxâ€œ\index{Bounding Box})}.

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtZellenBb}
  \end{center}

\item Nimm das Objekt zu allen Zellen dieses Rechtecks hinzu.
\end{itemize}

\begin{itemize}
\item[\Bad] fÃ¼gt das Objekt \iA in mehr Zellen ein als
  unbedingt nÃ¶tig

\item[\Good] sehr einfach zu realisieren, auch fÃ¼r komplexere Objekte
\end{itemize}

\pagebreak

\vspace*{-24mm}
\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus modifizierter Darstellungsalgorithmus

    fÃ¼r alle Zellen $Záµ¢â±¼$ des Rasters
    Â°Â°Â°fÃ¼r alle Pixel $P$ von Zelle $Záµ¢â±¼$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// insgesamt $p$-mal:
    Â°Â°Â°Â°Â°Â°Projektionsstrahl parametrisch darstellen
    Â°Â°Â°Â°Â°Â°$O^*$ := Âºâ€Hintergrundâ€œÂº
    Â°Â°Â°Â°Â°Â°$Î»^*$ := $-âˆ$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// zusammen $ğ’ª(1)$
    Â°Â°Â°Â°Â°Â°fÃ¼r alle Objekte $Oâ‚–$ in der $Záµ¢â±¼$-ListeÂ°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// ?-mal:
    Â°Â°Â°Â°Â°Â°Â°Â°Â°Schnitttest $Oâ‚–$ mit dem ProjektionsstrahlÂ°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// $ğ’ª(s)$
    Â°Â°Â°Â°Â°Â°Â°Â°Â°$O^*$ und $Î»^*$ aktualisierenÂ°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// $ğ’ª(1)$
    Â°Â°Â°Â°Â°Â°Pixel $P$ auf die $O^*$ entsprechende Farbe setzenÂ°Â°Â°Â°Â°Â°// $ğ’ª(z)$
  \end{AlgListInline}
\end{algorithmus}

Wie oft die innerste Schleife
â€\AlgInline!fÃ¼r alle Objekte $Oâ‚–$ in der $Záµ¢â±¼$-Liste!â€œ
\emph{insgesamt} durchlaufen wird, hÃ¤ngt davon ab,
\begin{itemize}
\item wie viele Zellen vorhanden sind und
\item wie viele Objekte jede Zellenliste (im Mittel) enthÃ¤lt.
\end{itemize}

\begin{description}
\item[Heuristik:]
  Im Mittel Ã¼berdecke jedes Objekt $\frac{1}{r}$ der Pixmap-FlÃ¤che.

  WÃ¤hle dann etwa $r$ Zellen.

\item[\emph{â€gutartigeâ€œ Szenen:}\index{gutartige Szene!Zell-Raster-Technik}%
  \index{Zell-Raster-Technik!gutartige Szene}]
  Jedes Objekt trifft im Mittel $ğ’ª(1)$ Zellen.

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtZellenGutartig}
  \end{center}

  \begin{itemize}
  \item[â‡’] Jedes Objekt wird bei $ğ’ª\fk{\frac{p}{r}}$ Pixeln betrachtet.

  \item[â‡’] insgesamt $ğ’ª\fk{\frac{p Â· o}{r}}$ Schnitttests
  \end{itemize}

  Gesamtaufwand:
  \begin{center}
    \begin{tabular}{Ll}
      \myred{ğ’ª\fk{\mdef{\underbrace{o Â· m}_{\text{Vorverarb.}}}
          + \frac{p Â· o}{r} Â· s + p Â· z}} & Operationen und \\
      \myred{ğ’ª(o)} & zusÃ¤tzlicher Speicher
    \end{tabular}
  \end{center}

  \pagebreak

  \vspace*{-20mm}
\item[\emph{â€bÃ¶sartigeâ€œ Szenen:}\index{bÃ¶sartige Szene!Zell-Raster-Technik}%
  \index{Zell-Raster-Technik!bÃ¶sartige Szene}]
  Jedes Objekt trifft im Mittel $ğ’ª\fk{\sqrt{r}}$ Zellen.

  \begin{center}
    \includegraphics[scale=0.4]{fig_sichtZellenBoesartig}
  \end{center}

  \begin{itemize}
  \item[â‡’] Jedes Objekt wird bei
    $ğ’ª\fk{\frac{p}{r} Â· \sqrt{r}} = ğ’ª\fk{\frac{p}{\sqrt{r}}}$ Pixeln betrachtet.

  \item[â‡’] insgesamt $ğ’ª\fk{\frac{p Â· o}{\sqrt{r}}}$
    Schnitttests
  \end{itemize}

  Gesamtaufwand:
  \vspace*{-5mm}
  \begin{center}
    \begin{tabular}{Ll}
      \myred{ğ’ª\fk{\mdef{\underbrace{o Â· \rk{\sqrt{r} + m}} _{\text{Vorverarb.}}}
          + \frac{p Â· o}{\sqrt{r}} Â· s + p Â· z}} & Operationen und \\
      \myred{ğ’ª\fk{o Â· \sqrt{r}}} & zusÃ¤tzlicher Speicher
    \end{tabular}
  \end{center}
\end{description}

\enlargethispage{4mm}
\begin{bemerkung}
  BÃ¶sartige Szenen mit $o â‰« 10â´$ kommen beispielsweise beim
  Chip-Design vor (lange und schmale Leiterbahnen).
\end{bemerkung}

\pagebreak


\vspace*{-30mm}
\subsection[Optimierung~II: â€$z$-Puffer-Algorithmusâ€œ]{Optimierung~II:
  â€$\mathbf{z}$-Puffer-Algorithmusâ€œ}
\label{subsec:sichtbarkeitZPuffer}

\begin{description}
\item[Idee:] Verzichte darauf, nur die \emph{im endgÃ¼ltigen Bild}
  sichtbaren Objektteile zu zeichnen.

  Zeichne die Objekte der Reihe nach; fÃ¼hre dabei die
  \emph{SichtbarkeitsprÃ¼fung nur gegenÃ¼ber den bereits gezeichneten Objekten} durch.
\end{description}

Pixel $P$ wird mit der Objekt $Oáµ¢$ entsprechenden Farbe belegt, falls
es
\begin{itemize}
\item bisher noch zu keinem Objekt $Oâ±¼$ ($j < i$) gehÃ¶rte oder
\item bisher die Farbe von $Oâ±¼$ ($j < i$) hatte und der
  zugehÃ¶rige Schnittpunkt $\point{S}â±¼$ â€hinterâ€œ dem
  Schnittpunkt $\point{S}áµ¢$ des Projektionsstrahls mit $Oáµ¢$
  liegt, \dH bezÃ¼glich des
  $(u, v, n)$-â€Projektionsebenen-Koordinatensystemsâ€œ gilt:

  \begin{center}
    \raisebox{4em}{$nâ±¼ < náµ¢$} \qquad\qquad
    \scalebox{0.45}{\huge\input{fig_sichtZBufferSituation}}%áµ¢â±¼
  \end{center}

\item[â‡’] FÃ¼r jedes Pixel muss die $n$-Koordinate des dort gerade
  sichtbaren (Schnitt-)Punkts gespeichert werden.

\item[â‡’] weiteres Feld der gleichen Dimension wie die Pixmap zur
  Speicherung der $n$-Koordinaten zu jedem Pixel

  \cmt{oft auch â€$z$-Koordinateâ€œ â‡ \emph{â€$\mathbf{z}$-Pufferâ€œ}\index{z-Puffer@$z$-Puffer}}
\end{itemize}

\pagebreak

\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus $z$-Puffer-ÂºAlgorithmusÂº

    fÃ¼r alle Pixel $P$ der Pixmap
    Â°Â°Â°$z[P]$ := $-âˆ$Â°Â°Â°Â°Â°// Hintergrund
    Â°Â°Â°setze Pixel $P$ auf Hintergrundfarbe
    fÃ¼r alle Objekte $Oáµ¢$
    Â°Â°Â°fÃ¼hre Â§3D Scan ConversionÂ§ ÂºfÃ¼rÂº Objekt $Oáµ¢$ durch, d.@\,@h. bestimme ÂºfÃ¼rÂº jedes erzeugte Pixel $P$
    Â°Â°Â°Â°Â°Â°Â°Â°auch die zugehÃ¶rige $z$- bzw. $n$-Koordinate $z_P$ des entsprechenden Punktes auf $Oáµ¢$
    Â°Â°Â°fÃ¼r alle hierbei erzeugten Pixel $P$
    Â°Â°Â°Â°Â°Â°wenn $z_P > z[P]$Â°Â°Â°Â°Â°// ist $Oáµ¢$ bei Pixel $P$ sichtbar?
    Â°Â°Â°Â°Â°Â°Â°Â°Â°$z[P]$ := $z_P$
    Â°Â°Â°Â°Â°Â°Â°Â°Â°setze Pixel $P$ auf die Farbe von Objekt $Oáµ¢$
  \end{AlgListInline}
\end{algorithmus}

\pagebreak

\begin{description}
\item[Aufwand:] \mbox{}

  \begin{tabular}{ll}
    â€Hintergrundâ€œ-Initialisierung & $ğ’ª(p Â· z)$ \\
    fÃ¼r alle Objekte $Oáµ¢$ & $o$-mal \\
    \qquad 3D Scan Conversion und sichtbare Pixel zeichnen & \qquad $ğ’ª(páµ¢ Â· z) + ğ’ª(h)$
  \end{tabular}

  mit

  \begin{align*}
    \mdef{páµ¢} &= \text{Anzahl der von Objekt $Oáµ¢$ Ã¼berdeckten Pixel} \\
    \mdef{ğ’ª(h)} &= \text{Verwaltungsaufwand fÃ¼r Scan Conversion}
  \end{align*}
\end{description}

\begin{beispiel}
  Die Objekte seien konvexe Polygone mit maximal $m$ Ecken, und im
  Mittel Ã¼berdecke jedes Objekt $\frac{1}{r}$ der Pixmap-FlÃ¤che.
  \begin{itemize}
  \item[â‡’] $âˆ‘\limits_{Oáµ¢} páµ¢ = o Â· \frac{p}{r}$,

  \item[] $ğ’ª(h) = ğ’ª(m)$

  \item[â‡’] Gesamtaufwand:
    \myred{$ğ’ª\fk{p Â· z + o Â· \frac{p}{r} Â· z + o Â· m}$}
  \end{itemize}
\end{beispiel}

\begin{itemize}
\item[\Good] ziemlich einfach und effizient, da auch 3D Scan
  Conversion \emph{inkrementell} mÃ¶glich ist.
  Bei \emph{Parallelprojektion} gilt \zB:
  \begin{itemize}
  \item Innerhalb einer Scan Line Ã¤ndert sich $z_P$ von einem
    Pixel zum nÃ¤chsten stets um einen festen Betrag
    $Î”â‚ z$,

  \item von einem Pixel zum darÃ¼ber liegenden der nÃ¤chsten
    Scan Line ist die Ã„nderung ebenfalls konstant:
    $Î”â‚‚ z$.
  \end{itemize}

\item[\Good] praktisch keine reelle Rechnung (keine Schnitttests!)

  \pagebreak

\item[\Good] in der Regel Hardware-unterstÃ¼tzt:

  \begin{center}
    \scalebox{0.425}{\huge\input{fig_sichtZBufferHardware}}
  \end{center}

  Vorteile:
  \begin{itemize}
  \item sehr bequem (kein Programm erforderlich!)

  \item sehr schnell, und nicht allzu teuer
  \end{itemize}
\end{itemize}
\Reached{WS14/15}{06}{2014/11/13}
\Reached{WS17/18}{05}{2017/11/09}

\pagebreak


\vspace*{-28mm}
\section{Der analytische Ansatz}
\label{sec:sichtbarkeitAnalytisch}

\begin{description}
\item[Ziel:] Bestimme rechnerisch die sichtbaren Teile der Objekte.
\end{description}
\Reached{WS19/20}{05}{2019/11/07}


\subsection{Hidden Line Removal fÃ¼r Polygonszenen}

\begin{description}
\item[Ansatz:] Bestimme fÃ¼r jede Strecke $s$ der Szene,
  welche StÃ¼cke von $s$ durch andere Polygone verdeckt werden.
\end{description}

\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus Hidden Line Removal ÂºfÃ¼rÂº Polygonszenen

    fÃ¼r jede Strecke $s$ der Szene
    Â°Â°Â°verdeckt := $âˆ…$Â°Â°Â°Â°Â°//  die durch andere Polygone verdeckten Teile von $s$
    Â°Â°Â°fÃ¼r alle Polygone, die $s$ nicht als Seite enthalten
    Â°Â°Â°Â°Â°Â°bestimme den hinter der Polygonebene liegenden Teil $s'$ von $s$
    Â°Â°Â°Â°Â°Â°wenn $s' â‰  âˆ…$
    Â°Â°Â°Â°Â°Â°Â°Â°Â°verdeckt := verdeckt $âˆª$ diejenigen Teile von $s'$, die durch das Polygon verdeckt werden
    Â°Â°Â°sichtbar := $s âˆ– \text{verdeckt}$
  \end{AlgListInline}
\end{algorithmus}

\minisec{Teilprobleme}

\begin{enumerate}
\item Welcher Teil der Strecke $s$ liegt hinter der Polygonebene?

  Sei $\mdef{\point{P}}$ ein fester Punkt in der Polygonebene
  (\zB eine Ecke des Polygons)

  und $\mdef{\vektor{v}}$ eine â€VorwÃ¤rtsâ€œ-Normale zur
  Polygonebene

  \cmt{in Richtung Projektionsrichtung \bzw\ -zentrum}.

  Berechne fÃ¼r die beiden Endpunkte $\point{E}áµ¢$ von $s$ die
  Zahlen
  \[ \mdef{Ïƒáµ¢} := \rk{\point{E}áµ¢ - \point{P}}áµ€ Â· \vektor{v} \,\text. \]

  Dann ist der hinter der Polygonebene liegende Teil von $s$ \bzgl
  der Parametrisierung
  \[ \vektor{q} = \point{E}â‚ + Î¼ \rk{\point{E}â‚‚ - \point{E}â‚} \,\text, \quad
    Î¼ âˆˆ \ek{0; 1} \,\text, \]
  von $s$ gegeben durch:
  \begin{center}
    \begin{tabular}{C|C|C}
      & Ïƒâ‚ â‰¥ 0 & Ïƒâ‚ < 0 \\ \hline
      Ïƒâ‚‚ â‰¥ 0 & s' = âˆ… & s' = \ek{0; - \frac{Ïƒâ‚}{Ïƒâ‚‚ - Ïƒâ‚}} \\
      Ïƒâ‚‚ < 0 & s' = \ek{-\frac{Ïƒâ‚}{Ïƒâ‚‚ - Ïƒâ‚}; 1} & s' = \ek{0; 1}
    \end{tabular}
  \end{center}

  \pagebreak

  \vspace*{-20mm}
\item Welche Teile von $s'$ werden durch das Polygon $Oáµ¢$ verdeckt?

  \begin{itemize}
  \item Projiziere Strecke und Polygon in die Projektionsebene

    \emph{oder}

    projiziere die Strecke in die Polygonebene und fÃ¼hre dort
    ein 2D-Koordinatensystem ein.

  \item Bestimme alle Parameterwerte $Î¼â‚, â€¦, Î¼â‚–$
    von Schnittpunkten der \emph{Geraden}
    \[ \vektor{q} = \point{E}â‚ + Î¼ Â· \rk{\point{E}â‚‚ - \point{E}â‚} \,\text, \quad Î¼ âˆˆ â„ \,\text, \]
    mit dem \emph{Rand} des Polygons
    (\vgl~\ref{subsec:scanConversionPolygoneGrundalgorithmus}).

    \vspace*{-14mm}
    \begin{center}
      \scalebox{0.5}{\huge\input{fig_sichtPolygoneSituation}}%Î¼â‚â‚‚â‚ƒâ‚„â‚…â‚†
    \end{center}

  \item Ordne diese Parameterwerte aufsteigend:
    $Î¼â‚ â‰¤ â€¦ â‰¤ Î¼â‚–$

  \item Die verdeckten Teile ergeben sich aus den Intervallen
    \[ \ek{Î¼â‚‚â±¼â‚‹â‚; Î¼â‚‚â±¼} âˆ© s' \,, \quad j = 1, â€¦, \frac{k}{2} \,\text. \]
  \end{itemize}
  \Reached{WS21/22}{05}{2021/11/11}

  \pagebreak

\item Wie werden die verdeckten Teile von $s$ verwaltet?
  
  \begin{itemize}
  \item Die verdeckten Teile bilden eine Menge disjunkter
    Teilintervalle von $\ek{0; 1}$:

    \begin{center}
      \scalebox{0.45}{\LARGE\input{fig_sichtPolygoneIntervalle}}%Î¼
    \end{center}

  \item Einzige hÃ¤ufig durchgefÃ¼hrte Operation mit dieser
    Menge: \emph{EinfÃ¼gen} eines neuen Intervalls und \ggf
    \emph{Verschmelzen} mit bereits enthaltenen Intervallen

    \begin{Hide}
      \begin{center}
        \scalebox{0.45}{\LARGE\selectinput{fig_sichtPolygoneVerschmelzen}{leer}}
      \end{center}
    \end{Hide}
  \end{itemize}
\end{enumerate}
\ReachedZoom{WS20/21}{05}{2020/11/26}

\pagebreak

\vspace*{-25mm}
\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus EinfÃ¼gen und Verschmelzen
    /* fÃ¼gt $I = \ek{\underline{Î¼}; \overline{Î¼}}$ in die aufsteigend geordnete Folge $Iâ‚ = \ek{\underline{Î¼}â‚; \overline{Î¼}â‚}$, â€¦, $Iâ‚— = \ek{\underline{Î¼}â‚—; \overline{Î¼}â‚—}$ ein und
    Â°Â°Â°verschmilzt Ã¼berlappende Intervalle;
    Â°Â°Â°zur Vereinfachung enthalte die Folge die beiden â€Abschlussgliederâ€œ
    Â°Â°Â°$Iâ‚€ {:}{=} \ek{-1; -1}$ und $Iâ‚—â‚Šâ‚ {:}{=} \ek{2; 2}$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°*/

    // wo liegen $\underline{Î¼}$ und $\overline{Î¼}$ bzgl. der Intervalle der Folge?
    bestimme $i âˆˆ \mk{0, â€¦, l}$ mit $\underline{Î¼}áµ¢ â‰¤ \underline{Î¼} < \underline{Î¼}áµ¢â‚Šâ‚$
    wenn $\overline{Î¼}áµ¢ < \underline{Î¼}$
    Â°Â°Â°$i$ := $i + 1$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// $\underline{Î¼}$ liegt â€hinterâ€œ $Iáµ¢$
    sonst
    Â°Â°Â°$\underline{Î¼}$ := $\underline{Î¼}áµ¢$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// $\underline{Î¼}$ liegt in $Iáµ¢$
    bestimme $j âˆˆ \mk{0, â€¦, l}$ mit $\underline{Î¼}â±¼ â‰¤ \overline{Î¼} < \underline{Î¼}â±¼â‚Šâ‚$
    wenn $\overline{Î¼}â±¼ â‰¥ \overline{Î¼}$
    Â°Â°Â°$\overline{Î¼}$ := $\overline{Î¼}â±¼$Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°Â°// $\overline{Î¼}$ liegt in $Iâ±¼$
    // mit den â€altenâ€œ Intervallen verschmelzen
    entferne die Intervalle $Iáµ¢$, $Iáµ¢â‚Šâ‚$, â€¦, $Iâ±¼$ aus der Folge
    fÃ¼ge das Intervall $\ek{\underline{Î¼}; \overline{Î¼}}$ an der Stelle $i$ der neuen Folge ein
  \end{AlgListInline}
  \Reached{WS18/19}{05}{2018/11/15}
\end{algorithmus}

\pagebreak

\textbf{Aufwand:}

Annahmen:
\begin{itemize}
\item Schneiden der gerade betrachteten Strecke mit allen
  Polygonen liefere insgesamt $\mdef{k}$ Intervalle $Iáµ¢$.

\item FÃ¼r $j = 1, â€¦, k$ enthalte die â€bisherige Vereinigungâ€œ
  \[ Vâ±¼ := â‹ƒáµ¢â‚Œâ‚Ê² Iáµ¢ \]
  jeweils hÃ¶chstens $\mdef{g}$ disjunkte Intervalle.

  \begin{description}
  \item[Beispiel:] \mbox{}

    \begin{center}
      \includegraphics[scale=0.5]{fig_sichtPolygoneAufwand}
    \end{center}

    Die $j = 12$ Intervalle verschmelzen zu
    \xfigMagentaIII{$g = 3$} disjunkten Intervallen.
  \end{description}

\item[â‡’] Es muss $k$-mal in eine Menge von hÃ¶chstens $g$
  Elementen eingefÃ¼gt werden.
\end{itemize}

\begin{itemize}
\item Datenstruktur~I: \emph{Feld}

  \begin{tabular}{ll}
    fÃ¼r jedes einzufÃ¼gende Intervall & \myred{$k$-mal} \\
    \qquad $i$ und $j$ bestimmen (binÃ¤re Suche!) & \qquad \myred{$ğ’ª(\log g)$} \\
    \qquad einfÃ¼gen und verschmelzen (\dH hÃ¶chstens $g$ Folgenelemente \\
    \qquad\qquad\qquad nach vorne oder hinten verschieben) & \qquad \myred{$ğ’ª(g)$} \\ \hline
    $âˆ‘$ & \myred{$ğ’ª(k Â· g)$}
  \end{tabular}

\item Datenstruktur~II: \emph{hÃ¶henbalancierter verketteter Baum}

  \begin{description}
  \item[Beispiel:] verketteter 2-3-Baum

    \begin{Hide}
      \begin{center}
        \resizebox{!}{50mm}{\LARGE\selectinput{fig_sichtPolygoneBaum}{leer}}%â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡
      \end{center}
    \end{Hide}
  \end{description}

  \begin{tabular}{ll}
    insgesamt $k$-mal einfÃ¼gen & \myred{Ã  $ğ’ª(\log g)$} \\
    insgesamt hÃ¶chstens $k$-mal entfernen & \myred{Ã  $ğ’ª(\log g)$} \\ \hline
    $âˆ‘$ & \myred{$ğ’ª(k Â· \log g)$}
  \end{tabular}
\end{itemize}


\subsection{Optimierungen fÃ¼r Polyederszenen}

\begin{description}
\item[Annahme:]
  Die darzustellenden Objekte sind \emph{Polyeder}\index{Polyeder}, \dH durch Polygone
  begrenzte KÃ¶rper.
\end{description}

\begin{description}
\item[Beobachtung 1:] \mbox{}

  \begin{center}
    \scalebox{0.5}{\huge\input{fig_sichtPolyederCulling}}
  \end{center}

  Wird eine Strecke $s$ von einem Polyeder $K$ teilweise verdeckt,
  so werden dieselben Streckenteile bereits durch die
  \emph{â€AuÃŸenseitenâ€œ}\index{AuÃŸenseite} von $K$ verdeckt.

  \begin{itemize}
  \item[â‡’] \emph{Zur Bestimmung der verdeckten Teile von $s$
      mÃ¼ssen die Innenseiten der KÃ¶rper gar nicht betrachtet
      werden.}
  \end{itemize}

  Innenseiten sind auÃŸerdem stets durch die AuÃŸenseiten desselben
  KÃ¶rpers verdeckt.

  \begin{itemize}
  \item[â‡’] \emph{Kanten von Innenseiten mÃ¼ssen nicht auf
      Verdeckung geprÃ¼ft werden.}
  \end{itemize}

  â‡ \emph{â€Cullingâ€œ}\index{Culling}
\end{description}

\minisec{Welche Polygone eines Polyeders sind AuÃŸenseiten?}

\begin{description}
\item[Methode~I:] Speichere jedes Polygon so ab, dass seine Ecken,
  \emph{von auÃŸerhalb} des KÃ¶rpers betrachtet,
  \emph{entgegen dem Uhrzeigersinn nummeriert} sind.

  \begin{center}
    \scalebox{0.475}{\huge\input{fig_sichtPolyederUmlaufsinn}}
  \end{center}

  Das Polygon ist genau dann eine AuÃŸenseite, wenn auch seine
  projizierten Ecken entgegen dem Uhrzeigersinn durchlaufen werden.

  \pagebreak

\item[Methode~II:] Speichere zu jedem Polygon einen â€nach auÃŸenâ€œ gerichteten
  Normalenvektor $\vektor{v}$ zur Polygonebene ab.

  \begin{center}
    \scalebox{0.475}{\huge\input{fig_sichtPolyederNormale}}
  \end{center}

  Das Polygon ist genau dann eine AuÃŸenseite, wenn
  \[ \angk{\vektor{v}, \widehat{\vektor{n}}} > 0 \,\text. \]
\end{description}

\pagebreak

\pngpage{Bilder/glai/flat-sphere-wireframe-noculling}

\pngpage{Bilder/glai/flat-sphere-wireframe-culling}

\begin{description}
\item[Beobachtung~2:]\mbox{}
  
  \begin{center}
    \scalebox{0.5}{\huge\input{fig_sichtPolyederKontur}}
  \end{center}

  Die AuÃŸenseiten eines KÃ¶rpers Ã¼berdecken mehrere Intervalle der
  Strecke; von diesen Intervallen verschmelzen \iA einige zu
  grÃ¶ÃŸeren Intervallen.

  Wenn gesichert ist, dass $s$ den KÃ¶rper $K$
  \emph{nicht durchdringt} (\zB weil bekannt ist, dass die KÃ¶rper disjunkt
  sind) und $K$ konvex ist, dann kann man die grÃ¶ÃŸeren Intervalle direkt erhalten,
  indem man die Strecke $s$ nicht gegenÃ¼ber den einzelnen
  AuÃŸenseiten von $K$, sondern gegenÃ¼ber der \emph{Kontur}\index{Kontur} von $K$
  testet.
\end{description}

\pagebreak

\vspace*{-27mm}
\minisec{Welche Kanten des KÃ¶rpers $\mathbf{K}$ gehÃ¶ren zu seiner Kontur?}

\begin{center}
  \scalebox{0.5}{\huge\input{fig_sichtPolyederKonturkanten}}
\end{center}

\begin{itemize}
\item Jede Kante der Kontur gehÃ¶rt sowohl zu einer AuÃŸenseite als
  auch zu einer Innenseite des KÃ¶rpers.
\end{itemize}

\emph{aber:}

\begin{itemize}
\item Ist $K$ nicht konvex, gilt die Beobachtung nicht mehr.

  \begin{Hide}
    \begin{center}
      \resizebox{!}{55mm}{\huge\selectinput{fig_sichtPolyederKonturproblem}{leer}}
    \end{center}
  \end{Hide}
  (Und Kanten(stÃ¼cke), die zu AuÃŸen- und Innenseiten gehÃ¶ren, gehÃ¶ren
  nicht unbedingt (vollstÃ¤ndig) zur Kontur.)
\end{itemize}
\Reached{WS15/16}{06}{2015/11/26}

\pagebreak

% Die Kontur eines Polyeders ist ein Polygon, aber \evtl mit LÃ¶chern:

% \begin{center}
%   \scalebox{0.5}{\input{fig_sichtPolyederLoch}}
% \end{center}

% \begin{itemize}
% \item[â‡’] Beschreibung der Kontur durch $m$ geschlossene
%   PolygonzÃ¼ge; davon ist genau einer
%   \emph{positiv}\index{positiv orientierter Polygonzug}%
%   \index{Polygonzug!positiv orientierter}
%   (entgegen dem Uhrzeigersinn) \emph{orientiert},
%   alle anderen negativ.
% \end{itemize}

% \begin{bemerkung}
%   Die Kontur kann in der Projektionsebene \emph{(2D)} beschrieben
%   werden!
% \end{bemerkung}


\section{Vereinfachte Algorithmen}

\subsection{Painter's Algorithm}
\label{subsec:paintersAlgorithm}

\begin{description}
\item[Beobachtung:] Die weiter hinten liegenden Objekte werden durch weiter vorne
  liegende Objekte teilweise verdeckt.

  (â‡ $z$-Puffer-Algorithmus,
  Abschnitt~\ref{subsec:sichtbarkeitZPuffer})

\item[Idee:] Statt fÃ¼r jedes einzelne Pixel die $z$-Koordinaten zu berechnen
  und dann zu entscheiden, ob das Pixel gezeichnet wird, sorgt man
  dafÃ¼r, dass jedes neue Objekt (\bzgl der bereits gezeichneten)
  \emph{vollstÃ¤ndig sichtbar} ist.
  \begin{itemize}
  \item[â‡’] Das neue Objekt darf hinter keinem der bereits
    gezeichneten liegen.
  \item[â‡’] Die Objekte werden in der Reihenfolge
    \emph{â€von hinten nach vorneâ€œ} gezeichnet.
  \end{itemize}
\end{description}

\begin{bemerkung}
  Selbst wenn eine solche Reihenfolge mÃ¶glich ist, ist sie nicht
  unbedingt einfach herzustellen.
\end{bemerkung}

\begin{description}
\item[Kriterium~I:] $Páµ¢$ liegt vor $Pâ±¼$, wenn fÃ¼r die maximalen $n$-Koordinaten
  (von Ecken) der Polygone gilt:
  \[ n_{\max}â½â±â¾ > n_{\max}â½Ê²â¾ \]

  \begin{center}
    \scalebox{0.5}{\huge\input{fig_sichtPaintersKorrekt}}%áµ¢â±¼
  \end{center}

  Dieses Kriterium ist \iA \emph{nicht korrekt}:

  \begin{Hide}
    \begin{center}
      \resizebox{!}{40mm}{\LARGE\selectinput{fig_sichtPaintersInkorrekt}{leer}}%â‚â‚‚â‚ƒ

      $n_{\max}â½Â²â¾ > n_{\max}â½Â¹â¾$, aber $Pâ‚$ verdeckt $Pâ‚‚$.
    \end{center}

    \bigskip

    Das entsprechende Kriterium mit $n_{\min}$ ist ebenfalls nicht
    immer korrekt.
  \end{Hide}

  \pagebreak

\item[Kriterium~II:]
  $Páµ¢$ liegt vor $Pâ±¼$, wenn $Páµ¢$ vor der \emph{Polygonebene} von $Pâ±¼$ liegt.

  \begin{center}
    \scalebox{0.6}{\Large\input{fig_sichtPaintersEbene1}}%áµ¢â±¼
  \end{center}

  \begin{itemize}
  \item WÃ¤hle eine â€VorwÃ¤rtsâ€œ-Normale $\vektor{v}$ zu $Pâ±¼$.

    (\dH $\angk{\vektor{v}, \widehat{\vektor{n}}} > 0$)
  \item WÃ¤hle eine feste Ecke $\point{E}â±¼$ von $Pâ±¼$.
  \item $Páµ¢$ liegt vor $Pâ±¼$, wenn
    \[ \angk{\point{E}áµ¢ - \point{E}â±¼, \vektor{v}} > 0 \quad
      \text{fÃ¼r alle Ecken $\point{E}áµ¢$ von $Páµ¢$} \,\text. \]
  \end{itemize}

  \pagebreak

  Das Kriterium ist korrekt, wenn die Polygone sich nicht
  durchdringen; es liefert aber nicht immer eine Ordnung.

  \begin{center}
    \scalebox{0.6}{\Large\input{fig_sichtPaintersEbene2}}%â‚â‚‚â‚ƒ
  \end{center}
  \Reached{WS16/17}{06}{2016/11/24}

\item[aber:] nicht immer ist eine Reihenfolge Ã¼berhaupt mÃ¶glich:

  \begin{center}
    \includegraphicsHide{scale=0.5}{fig_sichtPaintersUnmoeglich}
  \end{center}

  \pagebreak

\item[Anwendung von Painter's Algorithm:]
  Wenn die Polygone sich leicht \bzgl der $n$- \bzw $z$-Koordinate
  ordnen lassen, \zB bei FlÃ¤chen, die Ã¼ber einem \emph{Gitter}
  definiert sind:

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_sichtPaintersGitter}}
  \end{center}
\end{description}

\pagebreak

\pngpage{Bilder/uebung/painters}


\vspace*{-32mm}
\subsection{Der Silhouetten-Algorithmus}

\begin{description}
\item[Anwendung:]
  Darstellung von Funktionen $f = f(s, t)$ Ã¼ber einem
  Parameterrechteck $\ek{\underline{s}; \overline{s}} Ã— \ek{\underline{t}; \overline{t}}$

  \begin{center}
    \scalebox{0.45}{\huge\input{fig_sichtSilhouette1}}
  \end{center}

  Die Funktion wird Ã¼ber parallelen Strecken
  (\zB $t â‰¡ \text{const}$) abgetragen (â‡ Kurven), die
  verdeckten Teile der Kurven werden nicht gezeichnet.
\end{description}

\begin{bemerkung}
  Die FlÃ¤che zwischen den Kurven $t â‰¡ tâ‚$ und $t â‰¡ tâ‚‚$
  ist zusammenhÃ¤ngend und besitzt keine LÃ¶cher, also gilt dies auch
  fÃ¼r ihre Projektion.
  \begin{itemize}
  \item[â‡’] Die Silhouette (Kontur) des FlÃ¤chenstÃ¼cks bestimmt,
    was durch das FlÃ¤chenstÃ¼ck verdeckt wird.
  \end{itemize}
\end{bemerkung}

\pagebreak

\begin{center}
  \scalebox{0.55}{\LARGE\input{fig_sichtSilhouette2}}
\end{center}

Wenn man die Kurven $t â‰¡ \text{const}$ \emph{von vorne nach hinten}
zeichnet, dann wird die Kontur der bisher gezeichneten FlÃ¤che durch
zwei Felder beschrieben:

\begin{center}
  \begin{tabular}{Ll}
    j_{\min}[i] & Nummer des untersten bislang in Pixelspalte $i$ gezeichneten Pixels \\
    j_{\max}[i] & Nummer des obersten Pixels
  \end{tabular}
\end{center}

Die nÃ¤chste zu zeichnende Kurve wird aus einzelnen Strecken

\begin{center}
  von \quad
  $\underbrace{\rk{i - 1, jáµ¢â‚‹â‚}}_{\myred{\text{â€altâ€œ}}}$
  \quad nach \quad
  $\underbrace{\rk{i, jáµ¢}}_{\myred{\text{â€neuâ€œ}}}$
\end{center}
zusammengesetzt.

\pagebreak

\begin{tabular}{lp{15cm}c}
  \textbf{Fall~1:} & alt und neu liegen auf derselben Seite der Kontur:
  \begin{itemize}
  \item[â‡’] Strecke zeichnen, \par
    Kontur aktualisieren
  \end{itemize}
  & \makebox(0,0)[tl]{\scalebox{0.4}{\huge\input{fig_sichtSilhouetteFall1}}} \\[7em]
  \textbf{Fall~2:} & alt und neu liegen auf verschiedenen Seiten der Kontur:
  \begin{itemize}
  \item[â‡’] zwei Teilstrecken zeichnen, \par
    Kontur aktualisieren
  \end{itemize}
  & \makebox(0,0)[tl]{\scalebox{0.4}{\huge\input{fig_sichtSilhouetteFall2}}} \\[6em]
  \textbf{Fall~3:} & Einer der Punkte alt \bzw neu liegt innerhalb der Kontur, der
  andere auÃŸerhalb:
  \begin{itemize}
  \item[â‡’] eine Teilstrecke zeichnen, \par
    Kontur aktualisieren
  \end{itemize}
  & \makebox(0,0)[tl]{\scalebox{0.4}{\huge\input{fig_sichtSilhouetteFall3}}} \\[6em]
  \textbf{Fall~4:} & alt und neu liegen innerhalb der Kontur:
  \begin{itemize}
  \item[â‡’] Strecke vollstÃ¤ndig verdeckt
  \end{itemize}
  & \makebox(0,0)[tl]{\scalebox{0.4}{\huge\input{fig_sichtSilhouetteFall4}}}
\end{tabular}

\pagebreak

\pngpage{Bilder/uebung/silhouetten}
