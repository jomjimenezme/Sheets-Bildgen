\chapter{Sichtbarkeit}
\label{cha:sichtbarkeit}

\pagebreak

\begin{description}
\item[bisher:] \emph{„Drahtmodell“}-Darstellung\index{Drahtmodell-Darstellung}
  \emph{(wire frame)}\index{wire frame} aller Kanten aller Objekte

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtWireframe}
  \end{center}

\item[Ziel:]
  Elimination aller Strecken- und Flächenteile, die durch
  „weiter vorne liegende“ Flächen \emph{verdeckt} werden
  \emph{(hidden line\index{hidden line removal}\,/\,hidden surface removal%
    \index{hidden surface removal})}

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtRemoved}
  \end{center}
\end{description}

⇒ wesentlich \emph{plastischere Darstellung}


\section{Der Pixel-orientierte Ansatz}

\begin{center}
  \scalebox{0.6}{\LARGE\input{fig_sichtPixel}}
\end{center}

\begin{description}
\item[Beobachtung:]
  Pixel $(u, v)$ erhält die Farbe des Objekts, das
  \begin{itemize}
  \item den durch das Pixel gehenden Projektionsstrahl schneidet
  \end{itemize}
  und
  \begin{itemize}
  \item unter allen Objekten den am nächsten bei
    der Projektionsebene liegenden Schnittpunkt liefert.
  \end{itemize}

\item[Folgerung:]
  Gesucht ist der \emph{$\mathbf{n}$-maximale} Schnittpunkt des
  Projektionsstrahls mit einem Objekt.
\end{description}


\subsection{Naive Implementierung}

\begin{description}
\item[Ansatz:]
  Bestimme für jedes Pixel der Pixmap, welche Objekte der
  zugehörige Projektionsstrahl schneidet, und leite aus dem
  nächstgelegenen Schnittpunkt die Farbe des Pixels ab.
\end{description}

\begin{algorithmus}%
  \label{alg:visibleSurfaceRayTracing}
  \mbox{}\index{visible surface ray tracing}%
  \begin{AlgListInline}
    Algorithmus visible surface ray tracing

    für alle Pixel $P$ der Pixmap
    °°°stelle den Projektionsstrahl durch das Pixel in der Form $\point{q} = \point{q}₁ + λ · \rk{\point{q}₂ - \point{q}₁}$ dar,
    °°°°°°°°so dass Punkte mit größerem $λ$ º„weiter vorne“º liegen
    °°°$O^*$ := º„Hintergrund“º°°°°°// bislang nächstgelegenes Objekt
    °°°$λ^*$ := $-∞$°°°°°°°°°°°°°°// Parameterwert des zugehörigen Schnittpunkts
    °°°für alle Objekte $Oᵢ$
    °°°°°°§Schnitttest:§ Prüfe, ob der Projektionsstrahl das Objekt $Oᵢ$ trifft, und bestimme ggf.
    °°°°°°°°°°°den Parameterwert $λᵢ$ des Schnittpunkts
    °°°°°°wenn Schnittpunkt vorhanden und $λᵢ > λ^*$
    °°°°°°°°°$O^*$ := $Oᵢ$
    °°°°°°°°°$λ^*$ := $λᵢ$
    °°°setze Pixel $P$ auf die Farbe von Objekt $O^*$
  \end{AlgListInline}
\end{algorithmus}

\pagebreak

\vspace*{-19mm}
\begin{description}
\item[Aufwand:]
  problemrelevante Größen

  \begin{tabular}{Ll}
    \mdef{p} & Anzahl der Pixel in der Pixmap \\
    \mdef{o} & Anzahl der Objekte \\
    \mdef{𝒪(s)} & Aufwand für einen Schnitttest \\
    \mdef{𝒪(z)} & Aufwand zum Zeichnen eines Pixels
  \end{tabular}
  
  \bigskip

  \begin{tabular}{ll}
    für alle Pixel & $p$-mal \\
    \qquad Projektionsstrahl darstellen & \qquad $𝒪(1)$ \\
    \qquad $O^*$, $λ^*$ initialisieren & \qquad $𝒪(1)$ \\
    \qquad für alle Objekte & \qquad $o$-mal \\
    \qquad\qquad Schnitttest & \qquad\qquad $𝒪(s)$ \\
    \qquad\qquad $O^*$, $λ^*$ aktualisieren & \qquad\qquad $𝒪(1)$ \\
    \qquad Pixel zeichnen & \qquad $𝒪(z)$ \\ \hline
    $∑$ & \myred{$𝒪(p · o · s + p · z)$}
  \end{tabular}
\end{description}

\begin{bemerkungen} \mbox{}
  \begin{enumerate}
  \item Zeichnen eines Pixels ist \iA in $𝒪(z) = 𝒪(1)$
    möglich.
  \item Der Aufwand $𝒪(s)$ hängt davon ab, welche Objekte
    zugelassen werden und ob \emph{Vorverarbeitung der Objekte}
    erfolgt.
  \end{enumerate}
\end{bemerkungen}

\pagebreak

\begin{beispiel}
  Die darzustellenden Objekte sind
  \emph{konvexe Polygone mit höchstens $\mathbf{m}$ Ecken}.

  Jedes Polygon werde durch seine $\mdef{m'} ≤ m$ Ecken und
  einen „Vorwärts“-Normalenvektor $\vektor{v}$ zur Polygonebene
  gegeben.

  \begin{center}
    \scalebox{0.5}{\huge\input{fig_sichtKonvex1}}%₁₂₃₄₅
  \end{center}

  Die Ecken seien \emph{entgegen dem Uhrzeigersinn} nummeriert, wenn
  die Polygonebene „von vorne“ (\dH in Richtung $-\vektor{v}$)
  betrachtet wird.

  \pagebreak

  \begin{enumerate}
  \item \textbf{Schnitttest ohne Vorverarbeitung:}

    \begin{itemize}
    \item Bestimme den Schnittpunkt $\point{S}$ des Strahls mit der
      Polygonebene.

    \item $\point{S}$ liegt genau dann im (konvexen!) Polygon, wenn
      $\point{S}$ \emph{links jeder gerichteten Seite}
      $\overrightarrow{\point{V}ⱼ₋₁\point{V}ⱼ}$ liegt
      ($j = 1, …, m'$, mit $\point{V}₀ := \point{V}_{m'}$).
    \end{itemize}

    Wie prüft man, ob $\point{S}$ links oder rechts von
    $\overrightarrow{\point{V}ⱼ₋₁\point{V}ⱼ}$ liegt?

    \begin{center}
      \scalebox{0.5}{\huge\input{fig_sichtKonvex2}}%ⱼ₋₁
    \end{center}

    $\mdef{\vektor{l}} := \vektor{v} × \rk{\point{V}ⱼ - \point{V}ⱼ₋₁}$
    ist ein „nach links“ zeigender Vektor.

    \begin{itemize}
    \item[⇒] $\point{S}$ liegt genau dann links von
      $\overrightarrow{\point{V}ⱼ₋₁\point{V}ⱼ}$, wenn
      \[ \vektor{l}ᵀ · \rk{\point{S} - \point{V}ⱼ₋₁} > 0 \,\text. \]
    \end{itemize}

    \begin{AlgListInline}
      Algorithmus Schnitttest ohne Vorverarbeitung

      innen := true
      für $j = 1, …, m'$
      °°°innen := innen and $\rk{\vektor{v} × \rk{\point{V}ⱼ - \point{V}ⱼ₋₁}}ᵀ · \rk{\point{S} - \point{V}ⱼ₋₁} > 0$
    \end{AlgListInline}

    \begin{description}
    \item[Aufwand:] $\myred{𝒪(s)} = 𝒪\fk{m'} = \myred{𝒪(m)}$
    \end{description}
    
  \item \textbf{Schnitttest mit Vorverarbeitung:}
    
    \begin{itemize}
    \item Ein konvexes Polygon zerfällt in zwei (\evtl leere)
      horizontale und zwei \bzgl der $v$-Achse
      \emph{streng monotone Polygonzüge}\index{streng monotoner Polygonzug}%
      \index{Polygonzug!streng monotoner} $L$ \bzw $R$:

      \begin{center}
        \scalebox{0.5}{\huge\input{fig_sichtKonvex3}}
      \end{center}

    \item $\point{S}$ liegt genau dann im Polygon, wenn
      \begin{itemize}
      \item $v_{\textrm{min}} < \point{S}ᵥ < v_{\textrm{max}}$ und
      \item $\point{S}$ links der beiden monotonen Polygonzüge
        liegt.
      \end{itemize}

    \item Ein monotoner Polygonzug mit $k$ Ecken zerlegt die Ebene in $2k$ Gebiete:

      \begin{center}
        \scalebox{0.4}{\Huge\input{fig_sichtKonvex4}}
      \end{center}

      Durch \emph{binäre Suche} kann mit $𝒪(\log k)$ Vergleichen
      der horizontale Streifen bestimmt werden, in dem $\point{S}$
      liegt.
      Danach genügt \emph{1 „Links/Rechts-Test“} um zu
      entscheiden, ob $\point{S}$ links oder rechts des monotonen
      Polygonzugs liegt.
    \end{itemize}

    \begin{AlgListInline}
      Algorithmus Vorverarbeitung

      für alle konvexen Polygone $Oᵢ$
      °°°führe ein geeignetes $(u, v, w)$-Koordinatensystem ein, so dass $w ≡ 0$ die Polygonebene ist
      °°°rechne die Ecken $\point{V}ᵢ$ in $(u, v, w)$-Koordinaten um
      °°°bestimme minimale und maximale $v$-Koordinaten $v_{\textmd{\textrm{min}}}$ bzw. $v_{\textmd{\textrm{max}}}$
      °°°speichere die beiden monotonen Polygonzüge in Datenstrukturen, die ºfürº binäre Suche
      °°°°°°°°geeignet sind (z.@\,@B. Felder)
    \end{AlgListInline}

    \begin{description}
    \item[Aufwand:] \mbox{}

      \begin{tabular}{ll}
        für alle Polygone & $o$-mal \\
        \qquad $(u, v, w)$-System berechnen & \qquad $𝒪(1)$ \\
        \qquad $\point{V}ᵢ$ umrechnen & \qquad $𝒪(m)$ \\
        \qquad $v_{\textrm{min}}$, $v_{\textrm{max}}$ bestimmen & \qquad $𝒪(m)$ \\
        \qquad Polygonzüge extrahieren & \qquad $𝒪(m)$ \\ \hline
        $∑$ & \myred{$𝒪(o · m)$}
      \end{tabular}
    \end{description}

    \begin{AlgListInline}
      Algorithmus Schnitttest

      berechne den Schnittpunkt $\point{S} = \rk{Sₓ, S_y, S_z}$ des Projektionsstrahls mit der Polygonebene
      rechne $\point{S}$ in $(u, v, w)$-Koordinaten um
      wenn $v_{\textmd{\textrm{min}}} < Sᵥ < v_{\textmd{\textrm{max}}}$
      °°°// teste „$\point{S}$ links von $R$?“
      °°°bestimme mit binärer Suche denjenigen durch $R$ definierten Streifen $\ek{vⱼ₋₁; vⱼ}$,
      °°°°°°°°der $\point{S}$ enthält
      °°°innen := $\pmat{vⱼ₋₁ - vⱼ \\ uⱼ - uⱼ₋₁}ᵀ · \pmat{Sᵤ - uⱼ₋₁ \\ Sᵥ - vⱼ₋₁} > 0$
      °°°@\raisebox{-170pt}[0bp][100pt]{\scalebox{0.5}{\input{fig_sichtKonvex5}}}@
      °°°wenn innen
      °°°°°°teste º„º$\point{S}$ links von $L$?º“º°°°°°// analog
    \end{AlgListInline}%ⱼ₋₁

    \pagebreak

    \begin{description}
    \item[Aufwand:] \mbox{}

      \begin{tabular}{ll}
        $\point{S}$ berechnen & $𝒪(1)$ \\
        $\point{S}$ in $(u, v, w)$ umrechnen & $𝒪(1)$ \\
	für $R$ und $L$ & $2$-mal \\
        \qquad binäre Suche & \qquad $𝒪(\log m)$ \\
        \qquad innen testen & \qquad $𝒪(1)$ \\ \hline
        $∑$ & \myred{$𝒪(\log m)$}
      \end{tabular}
    \end{description}
  \end{enumerate}

  \begin{description}
  \item[Fazit:] Der Gesamtaufwand beträgt
    \begin{center}
      \begin{tabular}{Ll}
        𝒪(p · o · \myred{m} + p · z) & ohne Vorverarbeitung \\
        \multicolumn{2}{l}{und} \\
        𝒪(\myred{o · m} + p · o · \myred{\log m} + p · z) & mit Vorverarbeitung.
      \end{tabular}
    \end{center}
  \end{description}
\end{beispiel}

\pagebreak

\vspace*{-21mm}
\begin{bemerkung}
  Typische Größenordnungen:
  \begin{align*}
    p &= 1920 × 1080 ≈ 2 · 10⁶ \\
    o &≫ 1000
  \end{align*}
  ⇒ \emph{≫ 10⁹ Schnitttests} notwendig!
  \Reached{WS15/16}{05}{2015/11/19}

  Visible surface ray tracing ist
  \begin{itemize}
  \item[\Bad] sehr aufwändig

  \item[\Good] relativ leicht zu sehr anspruchsvollen
    Bilderzeugungsverfahren erweiterbar.

    ⇝ rekursives Raytracing
    (Abschnitt~\ref{sec:faerbungRayTracing})
  \end{itemize}
  \Reached{WS16/17}{05}{2016/11/17}
\end{bemerkung}


\subsection{Optimierung~I: Zell-Raster-Technik}
\label{subsec:sichtbarkeitZellRaster}
\index{Zell-Raster-Technik}

\begin{description}
\item[Idee:] In Algorithmus~\ref{alg:visibleSurfaceRayTracing} wird
  jeder Projektionsstrahl mit jedem Objekt geschnitten.

  Die Objekte sind aber meist verhältnismäßig klein, überdecken
  also nur einen Teil des Bildschirms.

  \begin{itemize}
  \item[⇒] Versuche, in einer \emph{Vorbereitungsphase}
    Information darüber zu sammeln, welche Objekte
    überhaupt mit welchen Projektionsstrahlen geschnitten
    werden müssen.
  \end{itemize}
\end{description}

\pagebreak

\vspace*{-20mm}
Es ist aufwändig (Rechenzeit, Speicherplatz), für jeden einzelnen
Strahl die geschnittenen Objekte zu bestimmen.

\begin{itemize}
\item[⇒] nur \emph{summarische Analyse}:

  \begin{itemize}
  \item Unterteile die Pixmap in $\mdef{r = r₁ × r₂}$
    \emph{„Zellen“}\index{Zelle}.

  \item Bestimme für jede Zelle alle Objekte, welche (zumindest
    teilweise) in die Zelle fallen.

    \scalebox{0.5}{\huge\input{fig_sichtZellenBsp}}%₁₂₃₄
    \quad
    \raisebox{4em}{%
      \begin{tabular}{ll}
        $Z₁₁$: & \xfigBlue{$O₁$}, \xfigRed{$O₂$}, \xfigGreenIII{$O₃$} \\
        $Z₁₂$: & \xfigBlue{$O₁$}, \xfigRed{$O₂$} \\
        $Z₁₃$: & \xfigBlue{$O₁$} \\
        $Z₂₁$: & \xfigRed{$O₂$}, \xfigGreenIII{$O₃$} \\
        $Z₂₂$: & \xfigBlue{$O₁$}, \xfigRed{$O₂$}, \xfigGreenIII{$O₃$} \\
        $Z₂₃$: & \xfigBlue{$O₁$} \\
        $Z₃₁$: & \xfigGreenIII{$O₃$} \\
        $Z₃₂$: & \xfigGreenIII{$O₃$}, \xfigMagentaIII{$O₄$} \\
        $Z₃₃$: & \xfigBlue{$O₁$}, \xfigMagentaIII{$O₄$}
      \end{tabular}}

  \item Jeder Projektionsstrahl geht durch eine Zelle.
    Führe nur Schnitttests mit den Objekten durch, welche die
    Zelle treffen.

    (Im obigen Beispiel geht der Strahl durch $Z₂₁$, also nur
    Schnitttests mit $O₂$ und $O₃$.)
  \end{itemize}
\end{itemize}

\begin{description}
\item[Frage:] Wie bestimmt man diese Objekte möglichst effizient?

\item[Antwort:] Man geht von den Objekten aus und bestimmt zu
  jedem Objekt die von ihm berührten Zellen!
\end{description}

\pagebreak

\minisec{Methode~I: „Scan Conversion“}

Das Zellraster kann als gröbere Pixmap mit $r₁ × r₂$
Pixeln interpretiert werden.

\begin{itemize}
\item[⇒] Die zu einem Objekt gehörenden Zellen können
  durch Scan Conversion in das Zellraster ermittelt werden.

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtZellenScan}
  \end{center}
\end{itemize}

\begin{itemize}
\item[\Good] liefert bestmögliche Aussage, \dH genau die
  berührten Zellen

\item[\Bad] verhältnismäßig aufwändig
\end{itemize}

\pagebreak

\minisec{Methode~II: „Bounding Box“}

\begin{itemize}
\item Projiziere alle Ecken des Objekts in das Zellraster.

\item Bestimme das kleinstmögliche achsenparallele Rechteck im
  Zellraster, das alle diese Ecken enthält \\
  \emph{(„Bounding Box“\index{Bounding Box})}.

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtZellenBb}
  \end{center}

\item Nimm das Objekt zu allen Zellen dieses Rechtecks hinzu.
\end{itemize}

\begin{itemize}
\item[\Bad] fügt das Objekt \iA in mehr Zellen ein als
  unbedingt nötig

\item[\Good] sehr einfach zu realisieren, auch für komplexere Objekte
\end{itemize}

\pagebreak

\vspace*{-24mm}
\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus modifizierter Darstellungsalgorithmus

    für alle Zellen $Zᵢⱼ$ des Rasters
    °°°für alle Pixel $P$ von Zelle $Zᵢⱼ$°°°°°°°°°°°°°°°°°°°°// insgesamt $p$-mal:
    °°°°°°Projektionsstrahl parametrisch darstellen
    °°°°°°$O^*$ := º„Hintergrund“º
    °°°°°°$λ^*$ := $-∞$°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°// zusammen $𝒪(1)$
    °°°°°°für alle Objekte $Oₖ$ in der $Zᵢⱼ$-Liste°°°°°°°°°°°°°°°// ?-mal:
    °°°°°°°°°Schnitttest $Oₖ$ mit dem Projektionsstrahl°°°°°°°°°°°°// $𝒪(s)$
    °°°°°°°°°$O^*$ und $λ^*$ aktualisieren°°°°°°°°°°°°°°°°°°°°°°°°°°°°// $𝒪(1)$
    °°°°°°Pixel $P$ auf die $O^*$ entsprechende Farbe setzen°°°°°°// $𝒪(z)$
  \end{AlgListInline}
\end{algorithmus}

Wie oft die innerste Schleife
„\AlgInline!für alle Objekte $Oₖ$ in der $Zᵢⱼ$-Liste!“
\emph{insgesamt} durchlaufen wird, hängt davon ab,
\begin{itemize}
\item wie viele Zellen vorhanden sind und
\item wie viele Objekte jede Zellenliste (im Mittel) enthält.
\end{itemize}

\begin{description}
\item[Heuristik:]
  Im Mittel überdecke jedes Objekt $\frac{1}{r}$ der Pixmap-Fläche.

  Wähle dann etwa $r$ Zellen.

\item[\emph{„gutartige“ Szenen:}\index{gutartige Szene!Zell-Raster-Technik}%
  \index{Zell-Raster-Technik!gutartige Szene}]
  Jedes Objekt trifft im Mittel $𝒪(1)$ Zellen.

  \begin{center}
    \includegraphics[scale=0.5]{fig_sichtZellenGutartig}
  \end{center}

  \begin{itemize}
  \item[⇒] Jedes Objekt wird bei $𝒪\fk{\frac{p}{r}}$ Pixeln betrachtet.

  \item[⇒] insgesamt $𝒪\fk{\frac{p · o}{r}}$ Schnitttests
  \end{itemize}

  Gesamtaufwand:
  \begin{center}
    \begin{tabular}{Ll}
      \myred{𝒪\fk{\mdef{\underbrace{o · m}_{\text{Vorverarb.}}}
          + \frac{p · o}{r} · s + p · z}} & Operationen und \\
      \myred{𝒪(o)} & zusätzlicher Speicher
    \end{tabular}
  \end{center}

  \pagebreak

  \vspace*{-20mm}
\item[\emph{„bösartige“ Szenen:}\index{bösartige Szene!Zell-Raster-Technik}%
  \index{Zell-Raster-Technik!bösartige Szene}]
  Jedes Objekt trifft im Mittel $𝒪\fk{\sqrt{r}}$ Zellen.

  \begin{center}
    \includegraphics[scale=0.4]{fig_sichtZellenBoesartig}
  \end{center}

  \begin{itemize}
  \item[⇒] Jedes Objekt wird bei
    $𝒪\fk{\frac{p}{r} · \sqrt{r}} = 𝒪\fk{\frac{p}{\sqrt{r}}}$ Pixeln betrachtet.

  \item[⇒] insgesamt $𝒪\fk{\frac{p · o}{\sqrt{r}}}$
    Schnitttests
  \end{itemize}

  Gesamtaufwand:
  \vspace*{-5mm}
  \begin{center}
    \begin{tabular}{Ll}
      \myred{𝒪\fk{\mdef{\underbrace{o · \rk{\sqrt{r} + m}} _{\text{Vorverarb.}}}
          + \frac{p · o}{\sqrt{r}} · s + p · z}} & Operationen und \\
      \myred{𝒪\fk{o · \sqrt{r}}} & zusätzlicher Speicher
    \end{tabular}
  \end{center}
\end{description}

\enlargethispage{4mm}
\begin{bemerkung}
  Bösartige Szenen mit $o ≫ 10⁴$ kommen beispielsweise beim
  Chip-Design vor (lange und schmale Leiterbahnen).
\end{bemerkung}

\pagebreak


\vspace*{-30mm}
\subsection[Optimierung~II: „$z$-Puffer-Algorithmus“]{Optimierung~II:
  „$\mathbf{z}$-Puffer-Algorithmus“}
\label{subsec:sichtbarkeitZPuffer}

\begin{description}
\item[Idee:] Verzichte darauf, nur die \emph{im endgültigen Bild}
  sichtbaren Objektteile zu zeichnen.

  Zeichne die Objekte der Reihe nach; führe dabei die
  \emph{Sichtbarkeitsprüfung nur gegenüber den bereits gezeichneten Objekten} durch.
\end{description}

Pixel $P$ wird mit der Objekt $Oᵢ$ entsprechenden Farbe belegt, falls
es
\begin{itemize}
\item bisher noch zu keinem Objekt $Oⱼ$ ($j < i$) gehörte oder
\item bisher die Farbe von $Oⱼ$ ($j < i$) hatte und der
  zugehörige Schnittpunkt $\point{S}ⱼ$ „hinter“ dem
  Schnittpunkt $\point{S}ᵢ$ des Projektionsstrahls mit $Oᵢ$
  liegt, \dH bezüglich des
  $(u, v, n)$-„Projektionsebenen-Koordinatensystems“ gilt:

  \begin{center}
    \raisebox{4em}{$nⱼ < nᵢ$} \qquad\qquad
    \scalebox{0.45}{\huge\input{fig_sichtZBufferSituation}}%ᵢⱼ
  \end{center}

\item[⇒] Für jedes Pixel muss die $n$-Koordinate des dort gerade
  sichtbaren (Schnitt-)Punkts gespeichert werden.

\item[⇒] weiteres Feld der gleichen Dimension wie die Pixmap zur
  Speicherung der $n$-Koordinaten zu jedem Pixel

  \cmt{oft auch „$z$-Koordinate“ ⇝ \emph{„$\mathbf{z}$-Puffer“}\index{z-Puffer@$z$-Puffer}}
\end{itemize}

\pagebreak

\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus $z$-Puffer-ºAlgorithmusº

    für alle Pixel $P$ der Pixmap
    °°°$z[P]$ := $-∞$°°°°°// Hintergrund
    °°°setze Pixel $P$ auf Hintergrundfarbe
    für alle Objekte $Oᵢ$
    °°°führe §3D Scan Conversion§ ºfürº Objekt $Oᵢ$ durch, d.@\,@h. bestimme ºfürº jedes erzeugte Pixel $P$
    °°°°°°°°auch die zugehörige $z$- bzw. $n$-Koordinate $z_P$ des entsprechenden Punktes auf $Oᵢ$
    °°°für alle hierbei erzeugten Pixel $P$
    °°°°°°wenn $z_P > z[P]$°°°°°// ist $Oᵢ$ bei Pixel $P$ sichtbar?
    °°°°°°°°°$z[P]$ := $z_P$
    °°°°°°°°°setze Pixel $P$ auf die Farbe von Objekt $Oᵢ$
  \end{AlgListInline}
\end{algorithmus}

\pagebreak

\begin{description}
\item[Aufwand:] \mbox{}

  \begin{tabular}{ll}
    „Hintergrund“-Initialisierung & $𝒪(p · z)$ \\
    für alle Objekte $Oᵢ$ & $o$-mal \\
    \qquad 3D Scan Conversion und sichtbare Pixel zeichnen & \qquad $𝒪(pᵢ · z) + 𝒪(h)$
  \end{tabular}

  mit

  \begin{align*}
    \mdef{pᵢ} &= \text{Anzahl der von Objekt $Oᵢ$ überdeckten Pixel} \\
    \mdef{𝒪(h)} &= \text{Verwaltungsaufwand für Scan Conversion}
  \end{align*}
\end{description}

\begin{beispiel}
  Die Objekte seien konvexe Polygone mit maximal $m$ Ecken, und im
  Mittel überdecke jedes Objekt $\frac{1}{r}$ der Pixmap-Fläche.
  \begin{itemize}
  \item[⇒] $∑\limits_{Oᵢ} pᵢ = o · \frac{p}{r}$,

  \item[] $𝒪(h) = 𝒪(m)$

  \item[⇒] Gesamtaufwand:
    \myred{$𝒪\fk{p · z + o · \frac{p}{r} · z + o · m}$}
  \end{itemize}
\end{beispiel}

\begin{itemize}
\item[\Good] ziemlich einfach und effizient, da auch 3D Scan
  Conversion \emph{inkrementell} möglich ist.
  Bei \emph{Parallelprojektion} gilt \zB:
  \begin{itemize}
  \item Innerhalb einer Scan Line ändert sich $z_P$ von einem
    Pixel zum nächsten stets um einen festen Betrag
    $Δ₁ z$,

  \item von einem Pixel zum darüber liegenden der nächsten
    Scan Line ist die Änderung ebenfalls konstant:
    $Δ₂ z$.
  \end{itemize}

\item[\Good] praktisch keine reelle Rechnung (keine Schnitttests!)

  \pagebreak

\item[\Good] in der Regel Hardware-unterstützt:

  \begin{center}
    \scalebox{0.425}{\huge\input{fig_sichtZBufferHardware}}
  \end{center}

  Vorteile:
  \begin{itemize}
  \item sehr bequem (kein Programm erforderlich!)

  \item sehr schnell, und nicht allzu teuer
  \end{itemize}
\end{itemize}
\Reached{WS14/15}{06}{2014/11/13}
\Reached{WS17/18}{05}{2017/11/09}

\pagebreak


\vspace*{-28mm}
\section{Der analytische Ansatz}
\label{sec:sichtbarkeitAnalytisch}

\begin{description}
\item[Ziel:] Bestimme rechnerisch die sichtbaren Teile der Objekte.
\end{description}
\Reached{WS19/20}{05}{2019/11/07}


\subsection{Hidden Line Removal für Polygonszenen}

\begin{description}
\item[Ansatz:] Bestimme für jede Strecke $s$ der Szene,
  welche Stücke von $s$ durch andere Polygone verdeckt werden.
\end{description}

\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus Hidden Line Removal ºfürº Polygonszenen

    für jede Strecke $s$ der Szene
    °°°verdeckt := $∅$°°°°°//  die durch andere Polygone verdeckten Teile von $s$
    °°°für alle Polygone, die $s$ nicht als Seite enthalten
    °°°°°°bestimme den hinter der Polygonebene liegenden Teil $s'$ von $s$
    °°°°°°wenn $s' ≠ ∅$
    °°°°°°°°°verdeckt := verdeckt $∪$ diejenigen Teile von $s'$, die durch das Polygon verdeckt werden
    °°°sichtbar := $s ∖ \text{verdeckt}$
  \end{AlgListInline}
\end{algorithmus}

\minisec{Teilprobleme}

\begin{enumerate}
\item Welcher Teil der Strecke $s$ liegt hinter der Polygonebene?

  Sei $\mdef{\point{P}}$ ein fester Punkt in der Polygonebene
  (\zB eine Ecke des Polygons)

  und $\mdef{\vektor{v}}$ eine „Vorwärts“-Normale zur
  Polygonebene

  \cmt{in Richtung Projektionsrichtung \bzw\ -zentrum}.

  Berechne für die beiden Endpunkte $\point{E}ᵢ$ von $s$ die
  Zahlen
  \[ \mdef{σᵢ} := \rk{\point{E}ᵢ - \point{P}}ᵀ · \vektor{v} \,\text. \]

  Dann ist der hinter der Polygonebene liegende Teil von $s$ \bzgl
  der Parametrisierung
  \[ \vektor{q} = \point{E}₁ + μ \rk{\point{E}₂ - \point{E}₁} \,\text, \quad
    μ ∈ \ek{0; 1} \,\text, \]
  von $s$ gegeben durch:
  \begin{center}
    \begin{tabular}{C|C|C}
      & σ₁ ≥ 0 & σ₁ < 0 \\ \hline
      σ₂ ≥ 0 & s' = ∅ & s' = \ek{0; - \frac{σ₁}{σ₂ - σ₁}} \\
      σ₂ < 0 & s' = \ek{-\frac{σ₁}{σ₂ - σ₁}; 1} & s' = \ek{0; 1}
    \end{tabular}
  \end{center}

  \pagebreak

  \vspace*{-20mm}
\item Welche Teile von $s'$ werden durch das Polygon $Oᵢ$ verdeckt?

  \begin{itemize}
  \item Projiziere Strecke und Polygon in die Projektionsebene

    \emph{oder}

    projiziere die Strecke in die Polygonebene und führe dort
    ein 2D-Koordinatensystem ein.

  \item Bestimme alle Parameterwerte $μ₁, …, μₖ$
    von Schnittpunkten der \emph{Geraden}
    \[ \vektor{q} = \point{E}₁ + μ · \rk{\point{E}₂ - \point{E}₁} \,\text, \quad μ ∈ ℝ \,\text, \]
    mit dem \emph{Rand} des Polygons
    (\vgl~\ref{subsec:scanConversionPolygoneGrundalgorithmus}).

    \vspace*{-14mm}
    \begin{center}
      \scalebox{0.5}{\huge\input{fig_sichtPolygoneSituation}}%μ₁₂₃₄₅₆
    \end{center}

  \item Ordne diese Parameterwerte aufsteigend:
    $μ₁ ≤ … ≤ μₖ$

  \item Die verdeckten Teile ergeben sich aus den Intervallen
    \[ \ek{μ₂ⱼ₋₁; μ₂ⱼ} ∩ s' \,, \quad j = 1, …, \frac{k}{2} \,\text. \]
  \end{itemize}
  \Reached{WS21/22}{05}{2021/11/11}

  \pagebreak

\item Wie werden die verdeckten Teile von $s$ verwaltet?
  
  \begin{itemize}
  \item Die verdeckten Teile bilden eine Menge disjunkter
    Teilintervalle von $\ek{0; 1}$:

    \begin{center}
      \scalebox{0.45}{\LARGE\input{fig_sichtPolygoneIntervalle}}%μ
    \end{center}

  \item Einzige häufig durchgeführte Operation mit dieser
    Menge: \emph{Einfügen} eines neuen Intervalls und \ggf
    \emph{Verschmelzen} mit bereits enthaltenen Intervallen

    \begin{Hide}
      \begin{center}
        \scalebox{0.45}{\LARGE\selectinput{fig_sichtPolygoneVerschmelzen}{leer}}
      \end{center}
    \end{Hide}
  \end{itemize}
\end{enumerate}
\ReachedZoom{WS20/21}{05}{2020/11/26}

\pagebreak

\vspace*{-25mm}
\begin{algorithmus} \mbox{}
  \begin{AlgListInline}
    Algorithmus Einfügen und Verschmelzen
    /* fügt $I = \ek{\underline{μ}; \overline{μ}}$ in die aufsteigend geordnete Folge $I₁ = \ek{\underline{μ}₁; \overline{μ}₁}$, …, $Iₗ = \ek{\underline{μ}ₗ; \overline{μ}ₗ}$ ein und
    °°°verschmilzt überlappende Intervalle;
    °°°zur Vereinfachung enthalte die Folge die beiden „Abschlussglieder“
    °°°$I₀ {:}{=} \ek{-1; -1}$ und $Iₗ₊₁ {:}{=} \ek{2; 2}$°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°*/

    // wo liegen $\underline{μ}$ und $\overline{μ}$ bzgl. der Intervalle der Folge?
    bestimme $i ∈ \mk{0, …, l}$ mit $\underline{μ}ᵢ ≤ \underline{μ} < \underline{μ}ᵢ₊₁$
    wenn $\overline{μ}ᵢ < \underline{μ}$
    °°°$i$ := $i + 1$°°°°°°°°°°°°// $\underline{μ}$ liegt „hinter“ $Iᵢ$
    sonst
    °°°$\underline{μ}$ := $\underline{μ}ᵢ$°°°°°°°°°°°°// $\underline{μ}$ liegt in $Iᵢ$
    bestimme $j ∈ \mk{0, …, l}$ mit $\underline{μ}ⱼ ≤ \overline{μ} < \underline{μ}ⱼ₊₁$
    wenn $\overline{μ}ⱼ ≥ \overline{μ}$
    °°°$\overline{μ}$ := $\overline{μ}ⱼ$°°°°°°°°°°°°// $\overline{μ}$ liegt in $Iⱼ$
    // mit den „alten“ Intervallen verschmelzen
    entferne die Intervalle $Iᵢ$, $Iᵢ₊₁$, …, $Iⱼ$ aus der Folge
    füge das Intervall $\ek{\underline{μ}; \overline{μ}}$ an der Stelle $i$ der neuen Folge ein
  \end{AlgListInline}
  \Reached{WS18/19}{05}{2018/11/15}
\end{algorithmus}

\pagebreak

\textbf{Aufwand:}

Annahmen:
\begin{itemize}
\item Schneiden der gerade betrachteten Strecke mit allen
  Polygonen liefere insgesamt $\mdef{k}$ Intervalle $Iᵢ$.

\item Für $j = 1, …, k$ enthalte die „bisherige Vereinigung“
  \[ Vⱼ := ⋃ᵢ₌₁ʲ Iᵢ \]
  jeweils höchstens $\mdef{g}$ disjunkte Intervalle.

  \begin{description}
  \item[Beispiel:] \mbox{}

    \begin{center}
      \includegraphics[scale=0.5]{fig_sichtPolygoneAufwand}
    \end{center}

    Die $j = 12$ Intervalle verschmelzen zu
    \xfigMagentaIII{$g = 3$} disjunkten Intervallen.
  \end{description}

\item[⇒] Es muss $k$-mal in eine Menge von höchstens $g$
  Elementen eingefügt werden.
\end{itemize}

\begin{itemize}
\item Datenstruktur~I: \emph{Feld}

  \begin{tabular}{ll}
    für jedes einzufügende Intervall & \myred{$k$-mal} \\
    \qquad $i$ und $j$ bestimmen (binäre Suche!) & \qquad \myred{$𝒪(\log g)$} \\
    \qquad einfügen und verschmelzen (\dH höchstens $g$ Folgenelemente \\
    \qquad\qquad\qquad nach vorne oder hinten verschieben) & \qquad \myred{$𝒪(g)$} \\ \hline
    $∑$ & \myred{$𝒪(k · g)$}
  \end{tabular}

\item Datenstruktur~II: \emph{höhenbalancierter verketteter Baum}

  \begin{description}
  \item[Beispiel:] verketteter 2-3-Baum

    \begin{Hide}
      \begin{center}
        \resizebox{!}{50mm}{\LARGE\selectinput{fig_sichtPolygoneBaum}{leer}}%₁₂₃₄₅₆₇
      \end{center}
    \end{Hide}
  \end{description}

  \begin{tabular}{ll}
    insgesamt $k$-mal einfügen & \myred{à $𝒪(\log g)$} \\
    insgesamt höchstens $k$-mal entfernen & \myred{à $𝒪(\log g)$} \\ \hline
    $∑$ & \myred{$𝒪(k · \log g)$}
  \end{tabular}
\end{itemize}


\subsection{Optimierungen für Polyederszenen}

\begin{description}
\item[Annahme:]
  Die darzustellenden Objekte sind \emph{Polyeder}\index{Polyeder}, \dH durch Polygone
  begrenzte Körper.
\end{description}

\begin{description}
\item[Beobachtung 1:] \mbox{}

  \begin{center}
    \scalebox{0.5}{\huge\input{fig_sichtPolyederCulling}}
  \end{center}

  Wird eine Strecke $s$ von einem Polyeder $K$ teilweise verdeckt,
  so werden dieselben Streckenteile bereits durch die
  \emph{„Außenseiten“}\index{Außenseite} von $K$ verdeckt.

  \begin{itemize}
  \item[⇒] \emph{Zur Bestimmung der verdeckten Teile von $s$
      müssen die Innenseiten der Körper gar nicht betrachtet
      werden.}
  \end{itemize}

  Innenseiten sind außerdem stets durch die Außenseiten desselben
  Körpers verdeckt.

  \begin{itemize}
  \item[⇒] \emph{Kanten von Innenseiten müssen nicht auf
      Verdeckung geprüft werden.}
  \end{itemize}

  ⇝ \emph{„Culling“}\index{Culling}
\end{description}

\minisec{Welche Polygone eines Polyeders sind Außenseiten?}

\begin{description}
\item[Methode~I:] Speichere jedes Polygon so ab, dass seine Ecken,
  \emph{von außerhalb} des Körpers betrachtet,
  \emph{entgegen dem Uhrzeigersinn nummeriert} sind.

  \begin{center}
    \scalebox{0.475}{\huge\input{fig_sichtPolyederUmlaufsinn}}
  \end{center}

  Das Polygon ist genau dann eine Außenseite, wenn auch seine
  projizierten Ecken entgegen dem Uhrzeigersinn durchlaufen werden.

  \pagebreak

\item[Methode~II:] Speichere zu jedem Polygon einen „nach außen“ gerichteten
  Normalenvektor $\vektor{v}$ zur Polygonebene ab.

  \begin{center}
    \scalebox{0.475}{\huge\input{fig_sichtPolyederNormale}}
  \end{center}

  Das Polygon ist genau dann eine Außenseite, wenn
  \[ \angk{\vektor{v}, \widehat{\vektor{n}}} > 0 \,\text. \]
\end{description}

\pagebreak

\pngpage{Bilder/glai/flat-sphere-wireframe-noculling}

\pngpage{Bilder/glai/flat-sphere-wireframe-culling}

\begin{description}
\item[Beobachtung~2:]\mbox{}
  
  \begin{center}
    \scalebox{0.5}{\huge\input{fig_sichtPolyederKontur}}
  \end{center}

  Die Außenseiten eines Körpers überdecken mehrere Intervalle der
  Strecke; von diesen Intervallen verschmelzen \iA einige zu
  größeren Intervallen.

  Wenn gesichert ist, dass $s$ den Körper $K$
  \emph{nicht durchdringt} (\zB weil bekannt ist, dass die Körper disjunkt
  sind) und $K$ konvex ist, dann kann man die größeren Intervalle direkt erhalten,
  indem man die Strecke $s$ nicht gegenüber den einzelnen
  Außenseiten von $K$, sondern gegenüber der \emph{Kontur}\index{Kontur} von $K$
  testet.
\end{description}

\pagebreak

\vspace*{-27mm}
\minisec{Welche Kanten des Körpers $\mathbf{K}$ gehören zu seiner Kontur?}

\begin{center}
  \scalebox{0.5}{\huge\input{fig_sichtPolyederKonturkanten}}
\end{center}

\begin{itemize}
\item Jede Kante der Kontur gehört sowohl zu einer Außenseite als
  auch zu einer Innenseite des Körpers.
\end{itemize}

\emph{aber:}

\begin{itemize}
\item Ist $K$ nicht konvex, gilt die Beobachtung nicht mehr.

  \begin{Hide}
    \begin{center}
      \resizebox{!}{55mm}{\huge\selectinput{fig_sichtPolyederKonturproblem}{leer}}
    \end{center}
  \end{Hide}
  (Und Kanten(stücke), die zu Außen- und Innenseiten gehören, gehören
  nicht unbedingt (vollständig) zur Kontur.)
\end{itemize}
\Reached{WS15/16}{06}{2015/11/26}

\pagebreak

% Die Kontur eines Polyeders ist ein Polygon, aber \evtl mit Löchern:

% \begin{center}
%   \scalebox{0.5}{\input{fig_sichtPolyederLoch}}
% \end{center}

% \begin{itemize}
% \item[⇒] Beschreibung der Kontur durch $m$ geschlossene
%   Polygonzüge; davon ist genau einer
%   \emph{positiv}\index{positiv orientierter Polygonzug}%
%   \index{Polygonzug!positiv orientierter}
%   (entgegen dem Uhrzeigersinn) \emph{orientiert},
%   alle anderen negativ.
% \end{itemize}

% \begin{bemerkung}
%   Die Kontur kann in der Projektionsebene \emph{(2D)} beschrieben
%   werden!
% \end{bemerkung}


\section{Vereinfachte Algorithmen}

\subsection{Painter's Algorithm}
\label{subsec:paintersAlgorithm}

\begin{description}
\item[Beobachtung:] Die weiter hinten liegenden Objekte werden durch weiter vorne
  liegende Objekte teilweise verdeckt.

  (⇝ $z$-Puffer-Algorithmus,
  Abschnitt~\ref{subsec:sichtbarkeitZPuffer})

\item[Idee:] Statt für jedes einzelne Pixel die $z$-Koordinaten zu berechnen
  und dann zu entscheiden, ob das Pixel gezeichnet wird, sorgt man
  dafür, dass jedes neue Objekt (\bzgl der bereits gezeichneten)
  \emph{vollständig sichtbar} ist.
  \begin{itemize}
  \item[⇒] Das neue Objekt darf hinter keinem der bereits
    gezeichneten liegen.
  \item[⇒] Die Objekte werden in der Reihenfolge
    \emph{„von hinten nach vorne“} gezeichnet.
  \end{itemize}
\end{description}

\begin{bemerkung}
  Selbst wenn eine solche Reihenfolge möglich ist, ist sie nicht
  unbedingt einfach herzustellen.
\end{bemerkung}

\begin{description}
\item[Kriterium~I:] $Pᵢ$ liegt vor $Pⱼ$, wenn für die maximalen $n$-Koordinaten
  (von Ecken) der Polygone gilt:
  \[ n_{\max}⁽ⁱ⁾ > n_{\max}⁽ʲ⁾ \]

  \begin{center}
    \scalebox{0.5}{\huge\input{fig_sichtPaintersKorrekt}}%ᵢⱼ
  \end{center}

  Dieses Kriterium ist \iA \emph{nicht korrekt}:

  \begin{Hide}
    \begin{center}
      \resizebox{!}{40mm}{\LARGE\selectinput{fig_sichtPaintersInkorrekt}{leer}}%₁₂₃

      $n_{\max}⁽²⁾ > n_{\max}⁽¹⁾$, aber $P₁$ verdeckt $P₂$.
    \end{center}

    \bigskip

    Das entsprechende Kriterium mit $n_{\min}$ ist ebenfalls nicht
    immer korrekt.
  \end{Hide}

  \pagebreak

\item[Kriterium~II:]
  $Pᵢ$ liegt vor $Pⱼ$, wenn $Pᵢ$ vor der \emph{Polygonebene} von $Pⱼ$ liegt.

  \begin{center}
    \scalebox{0.6}{\Large\input{fig_sichtPaintersEbene1}}%ᵢⱼ
  \end{center}

  \begin{itemize}
  \item Wähle eine „Vorwärts“-Normale $\vektor{v}$ zu $Pⱼ$.

    (\dH $\angk{\vektor{v}, \widehat{\vektor{n}}} > 0$)
  \item Wähle eine feste Ecke $\point{E}ⱼ$ von $Pⱼ$.
  \item $Pᵢ$ liegt vor $Pⱼ$, wenn
    \[ \angk{\point{E}ᵢ - \point{E}ⱼ, \vektor{v}} > 0 \quad
      \text{für alle Ecken $\point{E}ᵢ$ von $Pᵢ$} \,\text. \]
  \end{itemize}

  \pagebreak

  Das Kriterium ist korrekt, wenn die Polygone sich nicht
  durchdringen; es liefert aber nicht immer eine Ordnung.

  \begin{center}
    \scalebox{0.6}{\Large\input{fig_sichtPaintersEbene2}}%₁₂₃
  \end{center}
  \Reached{WS16/17}{06}{2016/11/24}

\item[aber:] nicht immer ist eine Reihenfolge überhaupt möglich:

  \begin{center}
    \includegraphicsHide{scale=0.5}{fig_sichtPaintersUnmoeglich}
  \end{center}

  \pagebreak

\item[Anwendung von Painter's Algorithm:]
  Wenn die Polygone sich leicht \bzgl der $n$- \bzw $z$-Koordinate
  ordnen lassen, \zB bei Flächen, die über einem \emph{Gitter}
  definiert sind:

  \begin{center}
    \scalebox{0.6}{\LARGE\input{fig_sichtPaintersGitter}}
  \end{center}
\end{description}

\pagebreak

\pngpage{Bilder/uebung/painters}


\vspace*{-32mm}
\subsection{Der Silhouetten-Algorithmus}

\begin{description}
\item[Anwendung:]
  Darstellung von Funktionen $f = f(s, t)$ über einem
  Parameterrechteck $\ek{\underline{s}; \overline{s}} × \ek{\underline{t}; \overline{t}}$

  \begin{center}
    \scalebox{0.45}{\huge\input{fig_sichtSilhouette1}}
  \end{center}

  Die Funktion wird über parallelen Strecken
  (\zB $t ≡ \text{const}$) abgetragen (⇝ Kurven), die
  verdeckten Teile der Kurven werden nicht gezeichnet.
\end{description}

\begin{bemerkung}
  Die Fläche zwischen den Kurven $t ≡ t₁$ und $t ≡ t₂$
  ist zusammenhängend und besitzt keine Löcher, also gilt dies auch
  für ihre Projektion.
  \begin{itemize}
  \item[⇒] Die Silhouette (Kontur) des Flächenstücks bestimmt,
    was durch das Flächenstück verdeckt wird.
  \end{itemize}
\end{bemerkung}

\pagebreak

\begin{center}
  \scalebox{0.55}{\LARGE\input{fig_sichtSilhouette2}}
\end{center}

Wenn man die Kurven $t ≡ \text{const}$ \emph{von vorne nach hinten}
zeichnet, dann wird die Kontur der bisher gezeichneten Fläche durch
zwei Felder beschrieben:

\begin{center}
  \begin{tabular}{Ll}
    j_{\min}[i] & Nummer des untersten bislang in Pixelspalte $i$ gezeichneten Pixels \\
    j_{\max}[i] & Nummer des obersten Pixels
  \end{tabular}
\end{center}

Die nächste zu zeichnende Kurve wird aus einzelnen Strecken

\begin{center}
  von \quad
  $\underbrace{\rk{i - 1, jᵢ₋₁}}_{\myred{\text{„alt“}}}$
  \quad nach \quad
  $\underbrace{\rk{i, jᵢ}}_{\myred{\text{„neu“}}}$
\end{center}
zusammengesetzt.

\pagebreak

\begin{tabular}{lp{15cm}c}
  \textbf{Fall~1:} & alt und neu liegen auf derselben Seite der Kontur:
  \begin{itemize}
  \item[⇒] Strecke zeichnen, \par
    Kontur aktualisieren
  \end{itemize}
  & \makebox(0,0)[tl]{\scalebox{0.4}{\huge\input{fig_sichtSilhouetteFall1}}} \\[7em]
  \textbf{Fall~2:} & alt und neu liegen auf verschiedenen Seiten der Kontur:
  \begin{itemize}
  \item[⇒] zwei Teilstrecken zeichnen, \par
    Kontur aktualisieren
  \end{itemize}
  & \makebox(0,0)[tl]{\scalebox{0.4}{\huge\input{fig_sichtSilhouetteFall2}}} \\[6em]
  \textbf{Fall~3:} & Einer der Punkte alt \bzw neu liegt innerhalb der Kontur, der
  andere außerhalb:
  \begin{itemize}
  \item[⇒] eine Teilstrecke zeichnen, \par
    Kontur aktualisieren
  \end{itemize}
  & \makebox(0,0)[tl]{\scalebox{0.4}{\huge\input{fig_sichtSilhouetteFall3}}} \\[6em]
  \textbf{Fall~4:} & alt und neu liegen innerhalb der Kontur:
  \begin{itemize}
  \item[⇒] Strecke vollständig verdeckt
  \end{itemize}
  & \makebox(0,0)[tl]{\scalebox{0.4}{\huge\input{fig_sichtSilhouetteFall4}}}
\end{tabular}

\pagebreak

\pngpage{Bilder/uebung/silhouetten}
